<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="11" failures="40" skipped="0" tests="79" time="28.675" timestamp="2025-07-19T13:39:14.502235" hostname="Jasons-MacBook-Pro-2.local"><testcase classname="test_app" name="test_config_loading" time="0.001" /><testcase classname="test_app" name="test_logging_setup" time="0.001"><failure message="assert 0 &gt;= 1&#10; +  where 0 = len([])&#10; +    where [] = &lt;Logger trading_app (INFO)&gt;.handlers">def test_logging_setup():
        """Test that logging is properly configured."""
        logger = logging.getLogger("trading_app")
        assert logger.level &lt;= logging.INFO
&gt;       assert len(logger.handlers) &gt;= 1
E       assert 0 &gt;= 1
E        +  where 0 = len([])
E        +    where [] = &lt;Logger trading_app (INFO)&gt;.handlers

test_app.py:29: AssertionError</failure></testcase><testcase classname="test_app" name="test_api_health" time="0.036" /><testcase classname="test_app" name="test_trading_service_init" time="0.008"><failure message="assert 59840.17978393556 == 100000.0&#10; +  where 59840.17978393556 = &lt;services.trading_service.TradingService object at 0x1667c64b0&gt;.current_balance&#10; +  and   100000.0 = &lt;config.Config object at 0x145278f20&gt;.INITIAL_BALANCE">def test_trading_service_init():
        """Test trading service initialization."""
        service = TradingService()
        assert service.initial_balance == config.INITIAL_BALANCE
&gt;       assert service.current_balance == config.INITIAL_BALANCE
E       assert 59840.17978393556 == 100000.0
E        +  where 59840.17978393556 = &lt;services.trading_service.TradingService object at 0x1667c64b0&gt;.current_balance
E        +  and   100000.0 = &lt;config.Config object at 0x145278f20&gt;.INITIAL_BALANCE

test_app.py:41: AssertionError</failure></testcase><testcase classname="test_app" name="test_sentiment_service_init" time="0.006" /><testcase classname="test_app" name="test_data_service_init" time="0.000" /><testcase classname="test_app" name="test_custom_exceptions" time="0.000" /><testcase classname="test_app" name="test_input_validation" time="0.004"><failure message="exceptions.DatabaseError: Database operation failed: [{'type': 'missing', 'loc': ('body', 'symbol'), 'msg': 'Field required', 'input': None, 'url': 'https://errors.pydantic.dev/2.5/v/missing'}]">self = MemoryObjectReceiveStream(_state=MemoryObjectStreamState(max_buffer_size=0, buffer=deque([]), open_send_channels=0, open_receive_channels=1, waiting_receivers=OrderedDict(), waiting_senders=OrderedDict()), _closed=False)

    async def receive(self) -&gt; T_co:
        await checkpoint()
        try:
&gt;           return self.receive_nowait()

venv/lib/python3.12/site-packages/anyio/streams/memory.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MemoryObjectReceiveStream(_state=MemoryObjectStreamState(max_buffer_size=0, buffer=deque([]), open_send_channels=0, open_receive_channels=1, waiting_receivers=OrderedDict(), waiting_senders=OrderedDict()), _closed=False)

    def receive_nowait(self) -&gt; T_co:
        """
        Receive the next item if it can be done without waiting.
    
        :return: the received item
        :raises ~anyio.ClosedResourceError: if this send stream has been closed
        :raises ~anyio.EndOfStream: if the buffer is empty and this stream has been
            closed from the sending end
        :raises ~anyio.WouldBlock: if there are no items in the buffer and no tasks
            waiting to send
    
        """
        if self._closed:
            raise ClosedResourceError
    
        if self._state.waiting_senders:
            # Get the item from the next sender
            send_event, item = self._state.waiting_senders.popitem(last=False)
            self._state.buffer.append(item)
            send_event.set()
    
        if self._state.buffer:
            return self._state.buffer.popleft()
        elif not self._state.open_send_channels:
            raise EndOfStream
    
&gt;       raise WouldBlock
E       anyio.WouldBlock

venv/lib/python3.12/site-packages/anyio/streams/memory.py:93: WouldBlock

During handling of the above exception, another exception occurred:

request = &lt;starlette.requests.Request object at 0x16678e870&gt;

    async def call_next(request: Request) -&gt; Response:
        app_exc: typing.Optional[Exception] = None
        send_stream, recv_stream = anyio.create_memory_object_stream()
    
        async def receive_or_disconnect() -&gt; Message:
            if response_sent.is_set():
                return {"type": "http.disconnect"}
    
            async with anyio.create_task_group() as task_group:
    
                async def wrap(func: typing.Callable[[], typing.Awaitable[T]]) -&gt; T:
                    result = await func()
                    task_group.cancel_scope.cancel()
                    return result
    
                task_group.start_soon(wrap, response_sent.wait)
                message = await wrap(request.receive)
    
            if response_sent.is_set():
                return {"type": "http.disconnect"}
    
            return message
    
        async def close_recv_stream_on_response_sent() -&gt; None:
            await response_sent.wait()
            recv_stream.close()
    
        async def send_no_error(message: Message) -&gt; None:
            try:
                await send_stream.send(message)
            except anyio.BrokenResourceError:
                # recv_stream has been closed, i.e. response_sent has been set.
                return
    
        async def coro() -&gt; None:
            nonlocal app_exc
    
            async with send_stream:
                try:
                    await self.app(scope, receive_or_disconnect, send_no_error)
                except Exception as exc:
                    app_exc = exc
    
        task_group.start_soon(close_recv_stream_on_response_sent)
        task_group.start_soon(coro)
    
        try:
&gt;           message = await recv_stream.receive()

venv/lib/python3.12/site-packages/starlette/middleware/base.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MemoryObjectReceiveStream(_state=MemoryObjectStreamState(max_buffer_size=0, buffer=deque([]), open_send_channels=0, open_receive_channels=1, waiting_receivers=OrderedDict(), waiting_senders=OrderedDict()), _closed=False)

    async def receive(self) -&gt; T_co:
        await checkpoint()
        try:
            return self.receive_nowait()
        except WouldBlock:
            # Add ourselves in the queue
            receive_event = Event()
            container: list[T_co] = []
            self._state.waiting_receivers[receive_event] = container
    
            try:
                await receive_event.wait()
            except get_cancelled_exc_class():
                # Ignore the immediate cancellation if we already received an item, so as not to
                # lose it
                if not container:
                    raise
            finally:
                self._state.waiting_receivers.pop(receive_event, None)
    
            if container:
                return container[0]
            else:
&gt;               raise EndOfStream
E               anyio.EndOfStream

venv/lib/python3.12/site-packages/anyio/streams/memory.py:118: EndOfStream

During handling of the above exception, another exception occurred:

    def test_input_validation():
        """Test input validation for adding stocks."""
        # Test invalid symbols
        invalid_symbols = ["", "  ", "123", "TOOLONGSYMBOL", "INVALID!"]
    
        for symbol in invalid_symbols:
&gt;           response = client.post("/api/stocks", json=symbol)

test_app.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/starlette/testclient.py:590: in post
    return super().post(
venv/lib/python3.12/site-packages/httpx/_client.py:1132: in post
    return self.request(
venv/lib/python3.12/site-packages/starlette/testclient.py:465: in request
    return super().request(
venv/lib/python3.12/site-packages/httpx/_client.py:814: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
venv/lib/python3.12/site-packages/httpx/_client.py:901: in send
    response = self._send_handling_auth(
venv/lib/python3.12/site-packages/httpx/_client.py:929: in _send_handling_auth
    response = self._send_handling_redirects(
venv/lib/python3.12/site-packages/httpx/_client.py:966: in _send_handling_redirects
    response = self._send_single_request(request)
venv/lib/python3.12/site-packages/httpx/_client.py:1002: in _send_single_request
    response = transport.handle_request(request)
venv/lib/python3.12/site-packages/starlette/testclient.py:342: in handle_request
    raise exc
venv/lib/python3.12/site-packages/starlette/testclient.py:339: in handle_request
    portal.call(self.app, scope, receive, send)
venv/lib/python3.12/site-packages/anyio/from_thread.py:277: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/concurrent/futures/_base.py:456: in result
    return self.__get_result()
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/concurrent/futures/_base.py:401: in __get_result
    raise self._exception
venv/lib/python3.12/site-packages/anyio/from_thread.py:217: in _call_func
    retval = await retval
venv/lib/python3.12/site-packages/fastapi/applications.py:1106: in __call__
    await super().__call__(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/applications.py:122: in __call__
    await self.middleware_stack(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/middleware/errors.py:184: in __call__
    raise exc
venv/lib/python3.12/site-packages/starlette/middleware/errors.py:162: in __call__
    await self.app(scope, receive, _send)
venv/lib/python3.12/site-packages/starlette/middleware/base.py:108: in __call__
    response = await self.dispatch_func(request, call_next)
main.py:61: in log_requests
    response = await call_next(request)
venv/lib/python3.12/site-packages/starlette/middleware/base.py:84: in call_next
    raise app_exc
venv/lib/python3.12/site-packages/starlette/middleware/base.py:70: in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
venv/lib/python3.12/site-packages/starlette/middleware/cors.py:83: in __call__
    await self.app(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/middleware/exceptions.py:79: in __call__
    raise exc
venv/lib/python3.12/site-packages/starlette/middleware/exceptions.py:68: in __call__
    await self.app(scope, receive, sender)
venv/lib/python3.12/site-packages/fastapi/middleware/asyncexitstack.py:14: in __call__
    async with AsyncExitStack() as stack:
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:754: in __aexit__
    raise exc_details[1]
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:737: in __aexit__
    cb_suppress = await cb(*exc_details)
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:231: in __aexit__
    await self.gen.athrow(value)
venv/lib/python3.12/site-packages/fastapi/concurrency.py:31: in contextmanager_in_threadpool
    await anyio.to_thread.run_sync(
venv/lib/python3.12/site-packages/anyio/to_thread.py:33: in run_sync
    return await get_asynclib().run_sync_in_worker_thread(
venv/lib/python3.12/site-packages/anyio/_backends/_asyncio.py:877: in run_sync_in_worker_thread
    return await future
venv/lib/python3.12/site-packages/anyio/_backends/_asyncio.py:807: in run
    result = context.run(func, *args)
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:158: in __exit__
    self.gen.throw(value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def get_db():
        db = SessionLocal()
        try:
            yield db
        except Exception as e:
            logger.error(f"Database session error: {str(e)}")
            db.rollback()
&gt;           raise DatabaseError(f"Database operation failed: {str(e)}")
E           exceptions.DatabaseError: Database operation failed: [{'type': 'missing', 'loc': ('body', 'symbol'), 'msg': 'Field required', 'input': None, 'url': 'https://errors.pydantic.dev/2.5/v/missing'}]

database.py:42: DatabaseError</failure></testcase><testcase classname="test_app" name="test_add_valid_stock" time="0.007"><failure message="exceptions.DatabaseError: Database operation failed: [{'type': 'missing', 'loc': ('body', 'symbol'), 'msg': 'Field required', 'input': None, 'url': 'https://errors.pydantic.dev/2.5/v/missing'}]">self = MemoryObjectReceiveStream(_state=MemoryObjectStreamState(max_buffer_size=0, buffer=deque([]), open_send_channels=0, open_receive_channels=1, waiting_receivers=OrderedDict(), waiting_senders=OrderedDict()), _closed=False)

    async def receive(self) -&gt; T_co:
        await checkpoint()
        try:
&gt;           return self.receive_nowait()

venv/lib/python3.12/site-packages/anyio/streams/memory.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MemoryObjectReceiveStream(_state=MemoryObjectStreamState(max_buffer_size=0, buffer=deque([]), open_send_channels=0, open_receive_channels=1, waiting_receivers=OrderedDict(), waiting_senders=OrderedDict()), _closed=False)

    def receive_nowait(self) -&gt; T_co:
        """
        Receive the next item if it can be done without waiting.
    
        :return: the received item
        :raises ~anyio.ClosedResourceError: if this send stream has been closed
        :raises ~anyio.EndOfStream: if the buffer is empty and this stream has been
            closed from the sending end
        :raises ~anyio.WouldBlock: if there are no items in the buffer and no tasks
            waiting to send
    
        """
        if self._closed:
            raise ClosedResourceError
    
        if self._state.waiting_senders:
            # Get the item from the next sender
            send_event, item = self._state.waiting_senders.popitem(last=False)
            self._state.buffer.append(item)
            send_event.set()
    
        if self._state.buffer:
            return self._state.buffer.popleft()
        elif not self._state.open_send_channels:
            raise EndOfStream
    
&gt;       raise WouldBlock
E       anyio.WouldBlock

venv/lib/python3.12/site-packages/anyio/streams/memory.py:93: WouldBlock

During handling of the above exception, another exception occurred:

request = &lt;starlette.requests.Request object at 0x166710c20&gt;

    async def call_next(request: Request) -&gt; Response:
        app_exc: typing.Optional[Exception] = None
        send_stream, recv_stream = anyio.create_memory_object_stream()
    
        async def receive_or_disconnect() -&gt; Message:
            if response_sent.is_set():
                return {"type": "http.disconnect"}
    
            async with anyio.create_task_group() as task_group:
    
                async def wrap(func: typing.Callable[[], typing.Awaitable[T]]) -&gt; T:
                    result = await func()
                    task_group.cancel_scope.cancel()
                    return result
    
                task_group.start_soon(wrap, response_sent.wait)
                message = await wrap(request.receive)
    
            if response_sent.is_set():
                return {"type": "http.disconnect"}
    
            return message
    
        async def close_recv_stream_on_response_sent() -&gt; None:
            await response_sent.wait()
            recv_stream.close()
    
        async def send_no_error(message: Message) -&gt; None:
            try:
                await send_stream.send(message)
            except anyio.BrokenResourceError:
                # recv_stream has been closed, i.e. response_sent has been set.
                return
    
        async def coro() -&gt; None:
            nonlocal app_exc
    
            async with send_stream:
                try:
                    await self.app(scope, receive_or_disconnect, send_no_error)
                except Exception as exc:
                    app_exc = exc
    
        task_group.start_soon(close_recv_stream_on_response_sent)
        task_group.start_soon(coro)
    
        try:
&gt;           message = await recv_stream.receive()

venv/lib/python3.12/site-packages/starlette/middleware/base.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MemoryObjectReceiveStream(_state=MemoryObjectStreamState(max_buffer_size=0, buffer=deque([]), open_send_channels=0, open_receive_channels=1, waiting_receivers=OrderedDict(), waiting_senders=OrderedDict()), _closed=False)

    async def receive(self) -&gt; T_co:
        await checkpoint()
        try:
            return self.receive_nowait()
        except WouldBlock:
            # Add ourselves in the queue
            receive_event = Event()
            container: list[T_co] = []
            self._state.waiting_receivers[receive_event] = container
    
            try:
                await receive_event.wait()
            except get_cancelled_exc_class():
                # Ignore the immediate cancellation if we already received an item, so as not to
                # lose it
                if not container:
                    raise
            finally:
                self._state.waiting_receivers.pop(receive_event, None)
    
            if container:
                return container[0]
            else:
&gt;               raise EndOfStream
E               anyio.EndOfStream

venv/lib/python3.12/site-packages/anyio/streams/memory.py:118: EndOfStream

During handling of the above exception, another exception occurred:

mock_get_market_data = &lt;MagicMock name='get_market_data' id='6013781680'&gt;

    @patch('services.data_service.DataService.get_market_data')
    def test_add_valid_stock(mock_get_market_data):
        """Test adding a valid stock symbol."""
        # Mock successful market data response
        mock_get_market_data.return_value = {
            "symbol": "TEST",
            "current_price": 100.0,
            "price_change": 1.0,
            "price_change_pct": 1.0
        }
    
&gt;       response = client.post("/api/stocks", json="TEST")

test_app.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/starlette/testclient.py:590: in post
    return super().post(
venv/lib/python3.12/site-packages/httpx/_client.py:1132: in post
    return self.request(
venv/lib/python3.12/site-packages/starlette/testclient.py:465: in request
    return super().request(
venv/lib/python3.12/site-packages/httpx/_client.py:814: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
venv/lib/python3.12/site-packages/httpx/_client.py:901: in send
    response = self._send_handling_auth(
venv/lib/python3.12/site-packages/httpx/_client.py:929: in _send_handling_auth
    response = self._send_handling_redirects(
venv/lib/python3.12/site-packages/httpx/_client.py:966: in _send_handling_redirects
    response = self._send_single_request(request)
venv/lib/python3.12/site-packages/httpx/_client.py:1002: in _send_single_request
    response = transport.handle_request(request)
venv/lib/python3.12/site-packages/starlette/testclient.py:342: in handle_request
    raise exc
venv/lib/python3.12/site-packages/starlette/testclient.py:339: in handle_request
    portal.call(self.app, scope, receive, send)
venv/lib/python3.12/site-packages/anyio/from_thread.py:277: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/concurrent/futures/_base.py:456: in result
    return self.__get_result()
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/concurrent/futures/_base.py:401: in __get_result
    raise self._exception
venv/lib/python3.12/site-packages/anyio/from_thread.py:217: in _call_func
    retval = await retval
venv/lib/python3.12/site-packages/fastapi/applications.py:1106: in __call__
    await super().__call__(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/applications.py:122: in __call__
    await self.middleware_stack(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/middleware/errors.py:184: in __call__
    raise exc
venv/lib/python3.12/site-packages/starlette/middleware/errors.py:162: in __call__
    await self.app(scope, receive, _send)
venv/lib/python3.12/site-packages/starlette/middleware/base.py:108: in __call__
    response = await self.dispatch_func(request, call_next)
main.py:61: in log_requests
    response = await call_next(request)
venv/lib/python3.12/site-packages/starlette/middleware/base.py:84: in call_next
    raise app_exc
venv/lib/python3.12/site-packages/starlette/middleware/base.py:70: in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
venv/lib/python3.12/site-packages/starlette/middleware/cors.py:83: in __call__
    await self.app(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/middleware/exceptions.py:79: in __call__
    raise exc
venv/lib/python3.12/site-packages/starlette/middleware/exceptions.py:68: in __call__
    await self.app(scope, receive, sender)
venv/lib/python3.12/site-packages/fastapi/middleware/asyncexitstack.py:14: in __call__
    async with AsyncExitStack() as stack:
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:754: in __aexit__
    raise exc_details[1]
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:737: in __aexit__
    cb_suppress = await cb(*exc_details)
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:231: in __aexit__
    await self.gen.athrow(value)
venv/lib/python3.12/site-packages/fastapi/concurrency.py:31: in contextmanager_in_threadpool
    await anyio.to_thread.run_sync(
venv/lib/python3.12/site-packages/anyio/to_thread.py:33: in run_sync
    return await get_asynclib().run_sync_in_worker_thread(
venv/lib/python3.12/site-packages/anyio/_backends/_asyncio.py:877: in run_sync_in_worker_thread
    return await future
venv/lib/python3.12/site-packages/anyio/_backends/_asyncio.py:807: in run
    result = context.run(func, *args)
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:158: in __exit__
    self.gen.throw(value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def get_db():
        db = SessionLocal()
        try:
            yield db
        except Exception as e:
            logger.error(f"Database session error: {str(e)}")
            db.rollback()
&gt;           raise DatabaseError(f"Database operation failed: {str(e)}")
E           exceptions.DatabaseError: Database operation failed: [{'type': 'missing', 'loc': ('body', 'symbol'), 'msg': 'Field required', 'input': None, 'url': 'https://errors.pydantic.dev/2.5/v/missing'}]

database.py:42: DatabaseError</failure></testcase><testcase classname="test_app" name="test_rate_limiting_methods" time="0.005" /><testcase classname="test_frontend_apis" name="test_api_endpoint" time="0.000"><error message="failed on setup with &quot;file /Users/jasonriedel/PyCharmProjects/Trading/backend/test_frontend_apis.py, line 10&#10;  def test_api_endpoint(method, url, data=None, description=&quot;&quot;):&#10;E       fixture 'method' not found&#10;&gt;       available fixtures: anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, doctest_namespace, event_loop, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/jasonriedel/PyCharmProjects/Trading/backend/test_frontend_apis.py:10&quot;">file /Users/jasonriedel/PyCharmProjects/Trading/backend/test_frontend_apis.py, line 10
  def test_api_endpoint(method, url, data=None, description=""):
E       fixture 'method' not found
&gt;       available fixtures: anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, doctest_namespace, event_loop, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/jasonriedel/PyCharmProjects/Trading/backend/test_frontend_apis.py:10</error></testcase><testcase classname="test_workflow" name="test_add_stocks" time="0.037" /><testcase classname="test_workflow" name="test_sentiment_analysis" time="3.903" /><testcase classname="test_workflow" name="test_generate_recommendations" time="6.607" /><testcase classname="test_workflow" name="test_view_recommendations" time="0.006" /><testcase classname="test_workflow" name="test_approve_recommendation" time="0.000"><error message="failed on setup with &quot;file /Users/jasonriedel/PyCharmProjects/Trading/backend/test_workflow.py, line 111&#10;  def test_approve_recommendation(recommendations: List[Dict]):&#10;E       fixture 'recommendations' not found&#10;&gt;       available fixtures: anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, doctest_namespace, event_loop, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/jasonriedel/PyCharmProjects/Trading/backend/test_workflow.py:111&quot;">file /Users/jasonriedel/PyCharmProjects/Trading/backend/test_workflow.py, line 111
  def test_approve_recommendation(recommendations: List[Dict]):
E       fixture 'recommendations' not found
&gt;       available fixtures: anyio_backend, anyio_backend_name, anyio_backend_options, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, class_mocker, cov, doctest_namespace, event_loop, mocker, module_mocker, monkeypatch, no_cover, package_mocker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, session_mocker, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/jasonriedel/PyCharmProjects/Trading/backend/test_workflow.py:111</error></testcase><testcase classname="test_workflow" name="test_check_performance" time="0.005" /><testcase classname="test_workflow" name="test_full_cycle" time="8.848" /><testcase classname="tests.test_auth.TestAuthService" name="test_init_with_google_client_id" time="0.001" /><testcase classname="tests.test_auth.TestAuthService" name="test_init_without_google_client_id" time="0.001" /><testcase classname="tests.test_auth.TestAuthService" name="test_verify_google_token_success" time="0.001" /><testcase classname="tests.test_auth.TestAuthService" name="test_verify_google_token_invalid_issuer" time="0.001" /><testcase classname="tests.test_auth.TestAuthService" name="test_verify_google_token_exception" time="0.001" /><testcase classname="tests.test_auth.TestAuthService" name="test_create_jwt_token" time="0.001" /><testcase classname="tests.test_auth.TestAuthService" name="test_verify_jwt_token_success" time="0.001" /><testcase classname="tests.test_auth.TestAuthService" name="test_verify_jwt_token_expired" time="0.001" /><testcase classname="tests.test_auth.TestAuthService" name="test_verify_jwt_token_invalid" time="0.000"><failure message="AttributeError: module 'jwt' has no attribute 'JWTError'. Did you mean: 'PyJWTError'?">self = &lt;jwt.api_jws.PyJWS object at 0x165cd65d0&gt;, jwt = b'invalid_token'

    def _load(self, jwt: str | bytes) -&gt; tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
            raise DecodeError(f"Invalid token type. Token must be a {bytes}")
    
        try:
&gt;           signing_input, crypto_segment = jwt.rsplit(b".", 1)
E           ValueError: not enough values to unpack (expected 2, got 1)

venv/lib/python3.12/site-packages/jwt/api_jws.py:257: ValueError

The above exception was the direct cause of the following exception:

self = &lt;auth.AuthService object at 0x166a6ea50&gt;, token = 'invalid_token'

    def verify_jwt_token(self, token: str) -&gt; dict:
        """Verify JWT token and return user data"""
        try:
&gt;           payload = jwt.decode(token, self.jwt_secret, algorithms=[self.jwt_algorithm])

auth.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/jwt/api_jwt.py:210: in decode
    decoded = self.decode_complete(
venv/lib/python3.12/site-packages/jwt/api_jwt.py:151: in decode_complete
    decoded = api_jws.decode_complete(
venv/lib/python3.12/site-packages/jwt/api_jws.py:198: in decode_complete
    payload, signing_input, header, signature = self._load(jwt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;jwt.api_jws.PyJWS object at 0x165cd65d0&gt;, jwt = b'invalid_token'

    def _load(self, jwt: str | bytes) -&gt; tuple[bytes, bytes, dict[str, Any], bytes]:
        if isinstance(jwt, str):
            jwt = jwt.encode("utf-8")
    
        if not isinstance(jwt, bytes):
            raise DecodeError(f"Invalid token type. Token must be a {bytes}")
    
        try:
            signing_input, crypto_segment = jwt.rsplit(b".", 1)
            header_segment, payload_segment = signing_input.split(b".", 1)
        except ValueError as err:
&gt;           raise DecodeError("Not enough segments") from err
E           jwt.exceptions.DecodeError: Not enough segments

venv/lib/python3.12/site-packages/jwt/api_jws.py:260: DecodeError

During handling of the above exception, another exception occurred:

self = &lt;tests.test_auth.TestAuthService object at 0x1665f4c80&gt;

    def test_verify_jwt_token_invalid(self):
        """Test JWT token verification with invalid token"""
        service = AuthService()
    
        with pytest.raises(HTTPException) as exc_info:
&gt;           service.verify_jwt_token("invalid_token")

tests/test_auth.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;auth.AuthService object at 0x166a6ea50&gt;, token = 'invalid_token'

    def verify_jwt_token(self, token: str) -&gt; dict:
        """Verify JWT token and return user data"""
        try:
            payload = jwt.decode(token, self.jwt_secret, algorithms=[self.jwt_algorithm])
            return payload
        except jwt.ExpiredSignatureError:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Token has expired"
            )
&gt;       except jwt.JWTError:
E       AttributeError: module 'jwt' has no attribute 'JWTError'. Did you mean: 'PyJWTError'?

auth.py:70: AttributeError</failure></testcase><testcase classname="tests.test_auth.TestAuthEndpoints" name="test_google_login_success" time="0.021" /><testcase classname="tests.test_auth.TestAuthEndpoints" name="test_google_login_invalid_token" time="0.005" /><testcase classname="tests.test_auth.TestAuthEndpoints" name="test_get_current_user_success" time="0.005" /><testcase classname="tests.test_auth.TestAuthEndpoints" name="test_get_current_user_no_token" time="0.004" /><testcase classname="tests.test_auth.TestAuthEndpoints" name="test_get_current_user_invalid_token" time="0.004"><failure message="AttributeError: module 'jwt' has no attribute 'JWTError'. Did you mean: 'PyJWTError'?">self = MemoryObjectReceiveStream(_state=MemoryObjectStreamState(max_buffer_size=0, buffer=deque([]), open_send_channels=0, open_receive_channels=1, waiting_receivers=OrderedDict(), waiting_senders=OrderedDict()), _closed=False)

    async def receive(self) -&gt; T_co:
        await checkpoint()
        try:
&gt;           return self.receive_nowait()

venv/lib/python3.12/site-packages/anyio/streams/memory.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MemoryObjectReceiveStream(_state=MemoryObjectStreamState(max_buffer_size=0, buffer=deque([]), open_send_channels=0, open_receive_channels=1, waiting_receivers=OrderedDict(), waiting_senders=OrderedDict()), _closed=False)

    def receive_nowait(self) -&gt; T_co:
        """
        Receive the next item if it can be done without waiting.
    
        :return: the received item
        :raises ~anyio.ClosedResourceError: if this send stream has been closed
        :raises ~anyio.EndOfStream: if the buffer is empty and this stream has been
            closed from the sending end
        :raises ~anyio.WouldBlock: if there are no items in the buffer and no tasks
            waiting to send
    
        """
        if self._closed:
            raise ClosedResourceError
    
        if self._state.waiting_senders:
            # Get the item from the next sender
            send_event, item = self._state.waiting_senders.popitem(last=False)
            self._state.buffer.append(item)
            send_event.set()
    
        if self._state.buffer:
            return self._state.buffer.popleft()
        elif not self._state.open_send_channels:
            raise EndOfStream
    
&gt;       raise WouldBlock
E       anyio.WouldBlock

venv/lib/python3.12/site-packages/anyio/streams/memory.py:93: WouldBlock

During handling of the above exception, another exception occurred:

request = &lt;starlette.requests.Request object at 0x166831700&gt;

    async def call_next(request: Request) -&gt; Response:
        app_exc: typing.Optional[Exception] = None
        send_stream, recv_stream = anyio.create_memory_object_stream()
    
        async def receive_or_disconnect() -&gt; Message:
            if response_sent.is_set():
                return {"type": "http.disconnect"}
    
            async with anyio.create_task_group() as task_group:
    
                async def wrap(func: typing.Callable[[], typing.Awaitable[T]]) -&gt; T:
                    result = await func()
                    task_group.cancel_scope.cancel()
                    return result
    
                task_group.start_soon(wrap, response_sent.wait)
                message = await wrap(request.receive)
    
            if response_sent.is_set():
                return {"type": "http.disconnect"}
    
            return message
    
        async def close_recv_stream_on_response_sent() -&gt; None:
            await response_sent.wait()
            recv_stream.close()
    
        async def send_no_error(message: Message) -&gt; None:
            try:
                await send_stream.send(message)
            except anyio.BrokenResourceError:
                # recv_stream has been closed, i.e. response_sent has been set.
                return
    
        async def coro() -&gt; None:
            nonlocal app_exc
    
            async with send_stream:
                try:
                    await self.app(scope, receive_or_disconnect, send_no_error)
                except Exception as exc:
                    app_exc = exc
    
        task_group.start_soon(close_recv_stream_on_response_sent)
        task_group.start_soon(coro)
    
        try:
&gt;           message = await recv_stream.receive()

venv/lib/python3.12/site-packages/starlette/middleware/base.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = MemoryObjectReceiveStream(_state=MemoryObjectStreamState(max_buffer_size=0, buffer=deque([]), open_send_channels=0, open_receive_channels=1, waiting_receivers=OrderedDict(), waiting_senders=OrderedDict()), _closed=False)

    async def receive(self) -&gt; T_co:
        await checkpoint()
        try:
            return self.receive_nowait()
        except WouldBlock:
            # Add ourselves in the queue
            receive_event = Event()
            container: list[T_co] = []
            self._state.waiting_receivers[receive_event] = container
    
            try:
                await receive_event.wait()
            except get_cancelled_exc_class():
                # Ignore the immediate cancellation if we already received an item, so as not to
                # lose it
                if not container:
                    raise
            finally:
                self._state.waiting_receivers.pop(receive_event, None)
    
            if container:
                return container[0]
            else:
&gt;               raise EndOfStream
E               anyio.EndOfStream

venv/lib/python3.12/site-packages/anyio/streams/memory.py:118: EndOfStream

During handling of the above exception, another exception occurred:

self = &lt;tests.test_auth.TestAuthEndpoints object at 0x1665f5c40&gt;
client = &lt;starlette.testclient.TestClient object at 0x1667a67e0&gt;

    def test_get_current_user_invalid_token(self, client):
        """Test getting current user info with invalid token"""
&gt;       response = client.get(
            "/api/auth/me",
            headers={"Authorization": "Bearer invalid_token"}
        )

tests/test_auth.py:196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/starlette/testclient.py:499: in get
    return super().get(
venv/lib/python3.12/site-packages/httpx/_client.py:1041: in get
    return self.request(
venv/lib/python3.12/site-packages/starlette/testclient.py:465: in request
    return super().request(
venv/lib/python3.12/site-packages/httpx/_client.py:814: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
venv/lib/python3.12/site-packages/httpx/_client.py:901: in send
    response = self._send_handling_auth(
venv/lib/python3.12/site-packages/httpx/_client.py:929: in _send_handling_auth
    response = self._send_handling_redirects(
venv/lib/python3.12/site-packages/httpx/_client.py:966: in _send_handling_redirects
    response = self._send_single_request(request)
venv/lib/python3.12/site-packages/httpx/_client.py:1002: in _send_single_request
    response = transport.handle_request(request)
venv/lib/python3.12/site-packages/starlette/testclient.py:342: in handle_request
    raise exc
venv/lib/python3.12/site-packages/starlette/testclient.py:339: in handle_request
    portal.call(self.app, scope, receive, send)
venv/lib/python3.12/site-packages/anyio/from_thread.py:277: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/concurrent/futures/_base.py:456: in result
    return self.__get_result()
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/concurrent/futures/_base.py:401: in __get_result
    raise self._exception
venv/lib/python3.12/site-packages/anyio/from_thread.py:217: in _call_func
    retval = await retval
venv/lib/python3.12/site-packages/fastapi/applications.py:1106: in __call__
    await super().__call__(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/applications.py:122: in __call__
    await self.middleware_stack(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/middleware/errors.py:184: in __call__
    raise exc
venv/lib/python3.12/site-packages/starlette/middleware/errors.py:162: in __call__
    await self.app(scope, receive, _send)
venv/lib/python3.12/site-packages/starlette/middleware/base.py:108: in __call__
    response = await self.dispatch_func(request, call_next)
main.py:61: in log_requests
    response = await call_next(request)
venv/lib/python3.12/site-packages/starlette/middleware/base.py:84: in call_next
    raise app_exc
venv/lib/python3.12/site-packages/starlette/middleware/base.py:70: in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
venv/lib/python3.12/site-packages/starlette/middleware/cors.py:83: in __call__
    await self.app(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/middleware/exceptions.py:79: in __call__
    raise exc
venv/lib/python3.12/site-packages/starlette/middleware/exceptions.py:68: in __call__
    await self.app(scope, receive, sender)
venv/lib/python3.12/site-packages/fastapi/middleware/asyncexitstack.py:20: in __call__
    raise e
venv/lib/python3.12/site-packages/fastapi/middleware/asyncexitstack.py:17: in __call__
    await self.app(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/routing.py:718: in __call__
    await route.handle(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/routing.py:276: in handle
    await self.app(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/routing.py:66: in app
    response = await func(request)
venv/lib/python3.12/site-packages/fastapi/routing.py:264: in app
    solved_result = await solve_dependencies(
venv/lib/python3.12/site-packages/fastapi/dependencies/utils.py:594: in solve_dependencies
    solved = await run_in_threadpool(call, **sub_values)
venv/lib/python3.12/site-packages/starlette/concurrency.py:41: in run_in_threadpool
    return await anyio.to_thread.run_sync(func, *args)
venv/lib/python3.12/site-packages/anyio/to_thread.py:33: in run_sync
    return await get_asynclib().run_sync_in_worker_thread(
venv/lib/python3.12/site-packages/anyio/_backends/_asyncio.py:877: in run_sync_in_worker_thread
    return await future
venv/lib/python3.12/site-packages/anyio/_backends/_asyncio.py:807: in run
    result = context.run(func, *args)
auth.py:81: in get_current_user
    return auth_service.verify_jwt_token(token)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;auth.AuthService object at 0x165caf020&gt;, token = 'invalid_token'

    def verify_jwt_token(self, token: str) -&gt; dict:
        """Verify JWT token and return user data"""
        try:
            payload = jwt.decode(token, self.jwt_secret, algorithms=[self.jwt_algorithm])
            return payload
        except jwt.ExpiredSignatureError:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Token has expired"
            )
&gt;       except jwt.JWTError:
E       AttributeError: module 'jwt' has no attribute 'JWTError'. Did you mean: 'PyJWTError'?

auth.py:70: AttributeError</failure></testcase><testcase classname="tests.test_auth.TestAuthEndpoints" name="test_health_check" time="0.004" /><testcase classname="tests.test_services.TestTradingService" name="test_calculate_position_size" time="0.007"><failure message="AttributeError: 'TradingService' object has no attribute 'calculate_position_size'">self = &lt;tests.test_services.TestTradingService object at 0x1665f7320&gt;
trading_service = &lt;services.trading_service.TradingService object at 0x1667a57c0&gt;

    def test_calculate_position_size(self, trading_service):
        """Test position size calculation"""
        # Test with valid inputs
&gt;       size = trading_service.calculate_position_size(100000, 150.0)
E       AttributeError: 'TradingService' object has no attribute 'calculate_position_size'

tests/test_services.py:28: AttributeError</failure></testcase><testcase classname="tests.test_services.TestTradingService" name="test_get_current_price_success" time="0.007"><failure message="AttributeError: module 'services.trading_service' has no attribute 'yfinance'">args = (&lt;tests.test_services.TestTradingService object at 0x1665f5010&gt;,)
keywargs = {'trading_service': &lt;services.trading_service.TradingService object at 0x1665f0590&gt;}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'services.trading_service.yfinance'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'services.trading_service' has no attribute 'yfinance'

/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_services.TestTradingService" name="test_get_current_price_fallback" time="0.007"><failure message="AttributeError: module 'services.trading_service' has no attribute 'yfinance'">args = (&lt;tests.test_services.TestTradingService object at 0x1665f7680&gt;,)
keywargs = {'trading_service': &lt;services.trading_service.TradingService object at 0x1669ae120&gt;}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'services.trading_service.yfinance'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'services.trading_service' has no attribute 'yfinance'

/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_services.TestTradingService" name="test_create_trade_success" time="0.008"><failure message="AttributeError: &lt;services.trading_service.TradingService object at 0x1678cce00&gt; does not have the attribute 'get_current_price'">self = &lt;tests.test_services.TestTradingService object at 0x1665f67e0&gt;
trading_service = &lt;services.trading_service.TradingService object at 0x1678cce00&gt;
mock_session = &lt;MagicMock spec='Session' id='6035846352'&gt;

    def test_create_trade_success(self, trading_service, mock_session):
        """Test successful trade creation"""
&gt;       with patch.object(trading_service, 'get_current_price', return_value=150.0), \
             patch.object(trading_service, 'recalculate_current_balance'), \
             patch.object(mock_session, 'add'), \
             patch.object(mock_session, 'commit'), \
             patch.object(mock_session, 'refresh'):

tests/test_services.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x167c3bcb0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;services.trading_service.TradingService object at 0x1678cce00&gt; does not have the attribute 'get_current_price'

/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1431: AttributeError</failure></testcase><testcase classname="tests.test_services.TestTradingService" name="test_create_trade_insufficient_balance" time="0.007"><failure message="AttributeError: &lt;services.trading_service.TradingService object at 0x166efdeb0&gt; does not have the attribute 'get_current_price'">self = &lt;tests.test_services.TestTradingService object at 0x1665f48c0&gt;
trading_service = &lt;services.trading_service.TradingService object at 0x166efdeb0&gt;
mock_session = &lt;MagicMock spec='Session' id='6021783072'&gt;

    def test_create_trade_insufficient_balance(self, trading_service, mock_session):
        """Test trade creation with insufficient balance"""
        trading_service.current_balance = 1000.0  # Low balance
    
&gt;       with patch.object(trading_service, 'get_current_price', return_value=150.0):

tests/test_services.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x166ed2360&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;services.trading_service.TradingService object at 0x166efdeb0&gt; does not have the attribute 'get_current_price'

/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1431: AttributeError</failure></testcase><testcase classname="tests.test_services.TestTradingService" name="test_close_trade_success" time="0.008"><failure message="AttributeError: &lt;services.trading_service.TradingService object at 0x166ed1d90&gt; does not have the attribute 'get_current_price'">self = &lt;tests.test_services.TestTradingService object at 0x1665f4e60&gt;
trading_service = &lt;services.trading_service.TradingService object at 0x166ed1d90&gt;
mock_session = &lt;MagicMock spec='Session' id='6034540352'&gt;

    def test_close_trade_success(self, trading_service, mock_session):
        """Test successful trade closure"""
        # Mock an open trade
        mock_trade = MagicMock()
        mock_trade.status = 'OPEN'
        mock_trade.trade_type = 'BUY'
        mock_trade.quantity = 10
        mock_trade.price = 150.0
        mock_trade.total_value = 1500.0
    
        mock_session.query.return_value.filter.return_value.first.return_value = mock_trade
    
&gt;       with patch.object(trading_service, 'get_current_price', return_value=155.0), \
             patch.object(trading_service, 'recalculate_current_balance'), \
             patch.object(mock_session, 'commit'):

tests/test_services.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x167c124e0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;services.trading_service.TradingService object at 0x166ed1d90&gt; does not have the attribute 'get_current_price'

/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1431: AttributeError</failure></testcase><testcase classname="tests.test_services.TestTradingService" name="test_calculate_performance_metrics" time="0.010"><failure message="assert 0 == 3">self = &lt;tests.test_services.TestTradingService object at 0x1665f5eb0&gt;
trading_service = &lt;services.trading_service.TradingService object at 0x167a37110&gt;
mock_session = &lt;MagicMock spec='Session' id='6034455104'&gt;

    def test_calculate_performance_metrics(self, trading_service, mock_session):
        """Test performance metrics calculation"""
        # Mock trades data
        mock_trades = [
            MagicMock(status='CLOSED', profit_loss=100.0),
            MagicMock(status='CLOSED', profit_loss=-50.0),
            MagicMock(status='CLOSED', profit_loss=75.0),
        ]
    
        mock_session.query.return_value.all.return_value = mock_trades
    
        with patch.object(trading_service, 'current_balance', 110000.0):
            metrics = trading_service.get_performance_metrics(mock_session)
    
&gt;           assert metrics['total_trades'] == 3
E           assert 0 == 3

tests/test_services.py:140: AssertionError</failure></testcase><testcase classname="tests.test_services.TestSentimentService" name="test_fetch_news_success" time="0.006"><failure message="AttributeError: 'SentimentService' object has no attribute 'fetch_news'">self = &lt;tests.test_services.TestSentimentService object at 0x1665f6b70&gt;
mock_get = &lt;MagicMock name='get' id='6016207088'&gt;
sentiment_service = &lt;services.sentiment_service.SentimentService object at 0x167ae7e00&gt;

    @patch('services.sentiment_service.requests.get')
    def test_fetch_news_success(self, mock_get, sentiment_service):
        """Test successful news fetching"""
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            'articles': [
                {
                    'title': 'Apple reports strong earnings',
                    'description': 'Apple Inc. reported better than expected earnings',
                    'publishedAt': '2023-01-01T12:00:00Z',
                    'url': 'https://example.com/article'
                }
            ]
        }
        mock_get.return_value = mock_response
    
&gt;       articles = sentiment_service.fetch_news('AAPL')
E       AttributeError: 'SentimentService' object has no attribute 'fetch_news'

tests/test_services.py:175: AttributeError</failure></testcase><testcase classname="tests.test_services.TestSentimentService" name="test_calculate_sentiment_positive" time="0.006"><failure message="AttributeError: 'SentimentService' object has no attribute 'calculate_sentiment'">self = &lt;tests.test_services.TestSentimentService object at 0x1665f4e30&gt;
sentiment_service = &lt;services.sentiment_service.SentimentService object at 0x166ef0140&gt;

    def test_calculate_sentiment_positive(self, sentiment_service):
        """Test sentiment calculation for positive text"""
        positive_text = "Apple stock is performing excellently with strong growth"
    
        with patch('services.sentiment_service.SentimentIntensityAnalyzer') as mock_analyzer:
            mock_analyzer.return_value.polarity_scores.return_value = {
                'compound': 0.8, 'pos': 0.7, 'neu': 0.2, 'neg': 0.1
            }
    
&gt;           sentiment = sentiment_service.calculate_sentiment(positive_text)
E           AttributeError: 'SentimentService' object has no attribute 'calculate_sentiment'

tests/test_services.py:188: AttributeError</failure></testcase><testcase classname="tests.test_services.TestSentimentService" name="test_calculate_sentiment_negative" time="0.006"><failure message="AttributeError: 'SentimentService' object has no attribute 'calculate_sentiment'">self = &lt;tests.test_services.TestSentimentService object at 0x1665f67b0&gt;
sentiment_service = &lt;services.sentiment_service.SentimentService object at 0x166964ec0&gt;

    def test_calculate_sentiment_negative(self, sentiment_service):
        """Test sentiment calculation for negative text"""
        negative_text = "Apple stock crashes amid terrible earnings report"
    
        with patch('services.sentiment_service.SentimentIntensityAnalyzer') as mock_analyzer:
            mock_analyzer.return_value.polarity_scores.return_value = {
                'compound': -0.8, 'pos': 0.1, 'neu': 0.2, 'neg': 0.7
            }
    
&gt;           sentiment = sentiment_service.calculate_sentiment(negative_text)
E           AttributeError: 'SentimentService' object has no attribute 'calculate_sentiment'

tests/test_services.py:200: AttributeError</failure></testcase><testcase classname="tests.test_services.TestSentimentService" name="test_analyze_stock_sentiment_success" time="0.006"><failure message="AttributeError: &lt;services.sentiment_service.SentimentService object at 0x167c82030&gt; does not have the attribute 'fetch_news'">self = &lt;tests.test_services.TestSentimentService object at 0x1665f6990&gt;
sentiment_service = &lt;services.sentiment_service.SentimentService object at 0x167c82030&gt;
mock_session = &lt;MagicMock spec='Session' id='6019365104'&gt;

    def test_analyze_stock_sentiment_success(self, sentiment_service, mock_session):
        """Test complete stock sentiment analysis"""
&gt;       with patch.object(sentiment_service, 'fetch_news') as mock_fetch, \
             patch.object(sentiment_service, 'calculate_sentiment') as mock_calc, \
             patch.object(mock_session, 'add'), \
             patch.object(mock_session, 'commit'), \
             patch.object(mock_session, 'refresh'):

tests/test_services.py:205: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x166c83f80&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;services.sentiment_service.SentimentService object at 0x167c82030&gt; does not have the attribute 'fetch_news'

/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1431: AttributeError</failure></testcase><testcase classname="tests.test_services.TestDataService" name="test_add_stock_success" time="0.004"><failure message="exceptions.StockDataError: Failed to add stock AAPL: '&gt;' not supported between instances of 'MagicMock' and 'int'">self = &lt;services.data_service.DataService object at 0x1678966f0&gt;
db = &lt;MagicMock spec='Session' id='6032028352'&gt;, symbol = 'AAPL'

    def add_stock(self, db: Session, symbol: str) -&gt; Dict:
        """Add a new stock to track with validation and error handling."""
        try:
            # Validate input
            if not symbol or not symbol.strip():
                raise StockDataError("Symbol cannot be empty")
    
            symbol = symbol.upper().strip()
    
            # Validate symbol format (basic check)
            if not symbol.isalpha() or len(symbol) &gt; 10:
                raise StockDataError(f"Invalid symbol format: {symbol}")
    
            self.logger.info(f"Adding stock to tracking: {symbol}")
    
            # Remove symbol from tracked_stocks if it already exists
            if symbol in self.tracked_stocks:
                self.tracked_stocks.remove(symbol)
                self.logger.info(f"Removed existing {symbol} from tracked stocks")
    
            # Delete all existing StockData entries for this symbol
            deleted_count = db.query(StockData).filter(StockData.symbol == symbol).delete()
&gt;           if deleted_count &gt; 0:
E           TypeError: '&gt;' not supported between instances of 'MagicMock' and 'int'

services/data_service.py:268: TypeError

During handling of the above exception, another exception occurred:

self = &lt;tests.test_services.TestDataService object at 0x1665c3cb0&gt;
data_service = &lt;services.data_service.DataService object at 0x1678966f0&gt;
mock_session = &lt;MagicMock spec='Session' id='6032028352'&gt;

    def test_add_stock_success(self, data_service, mock_session):
        """Test successful stock addition"""
        mock_session.query.return_value.filter.return_value.first.return_value = None
    
        with patch.object(mock_session, 'add'), \
             patch.object(mock_session, 'commit'), \
             patch.object(mock_session, 'refresh'):
    
&gt;           result = data_service.add_stock(mock_session, 'AAPL')

tests/test_services.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;services.data_service.DataService object at 0x1678966f0&gt;
db = &lt;MagicMock spec='Session' id='6032028352'&gt;, symbol = 'AAPL'

    def add_stock(self, db: Session, symbol: str) -&gt; Dict:
        """Add a new stock to track with validation and error handling."""
        try:
            # Validate input
            if not symbol or not symbol.strip():
                raise StockDataError("Symbol cannot be empty")
    
            symbol = symbol.upper().strip()
    
            # Validate symbol format (basic check)
            if not symbol.isalpha() or len(symbol) &gt; 10:
                raise StockDataError(f"Invalid symbol format: {symbol}")
    
            self.logger.info(f"Adding stock to tracking: {symbol}")
    
            # Remove symbol from tracked_stocks if it already exists
            if symbol in self.tracked_stocks:
                self.tracked_stocks.remove(symbol)
                self.logger.info(f"Removed existing {symbol} from tracked stocks")
    
            # Delete all existing StockData entries for this symbol
            deleted_count = db.query(StockData).filter(StockData.symbol == symbol).delete()
            if deleted_count &gt; 0:
                self.logger.info(f"Deleted {deleted_count} existing records for {symbol}")
            db.commit()
    
            # Rate limiting
            self._rate_limit()
    
            # Validate symbol by getting market data
            market_data = self.get_market_data(symbol, days=1)
    
            # Check if market data indicates an invalid symbol
            if "error" in market_data or market_data.get("current_price", 0) &lt;= 0:
                raise StockDataError(f"Invalid or unavailable stock symbol: {symbol}")
    
            # Add to tracked stocks
            self.tracked_stocks.append(symbol)
    
            # Save initial data
            try:
                stock_data = self.save_stock_data(db, symbol)
                self.logger.info(f"Saved initial stock data for {symbol}")
            except Exception as e:
                self.logger.warning(f"Could not save initial stock data for {symbol}: {str(e)}")
                # Don't fail the entire operation if we can't save to DB
    
            self.logger.info(f"Successfully added {symbol} to tracking")
            return {
                "message": f"Successfully added {symbol}",
                "symbol": symbol,
                "data": market_data
            }
    
        except StockDataError:
            db.rollback()
            raise
        except Exception as e:
            self.logger.error(f"Unexpected error adding stock {symbol}: {str(e)}")
            db.rollback()
&gt;           raise StockDataError(f"Failed to add stock {symbol}: {str(e)}")
E           exceptions.StockDataError: Failed to add stock AAPL: '&gt;' not supported between instances of 'MagicMock' and 'int'

services/data_service.py:306: StockDataError</failure></testcase><testcase classname="tests.test_services.TestDataService" name="test_add_stock_already_exists" time="0.002"><failure message="assert 'already being tracked' in &quot;Failed to add stock AAPL: '&gt;' not supported between instances of 'MagicMock' and 'int'&quot;&#10; +  where &quot;Failed to add stock AAPL: '&gt;' not supported between instances of 'MagicMock' and 'int'&quot; = str(StockDataError(&quot;Failed to add stock AAPL: '&gt;' not supported between instances of 'MagicMock' and 'int'&quot;))&#10; +    where StockDataError(&quot;Failed to add stock AAPL: '&gt;' not supported between instances of 'MagicMock' and 'int'&quot;) = &lt;ExceptionInfo StockDataError(&quot;Failed to add stock AAPL: '&gt;' not supported between instances of 'MagicMock' and 'int'&quot;) tblen=2&gt;.value">self = &lt;tests.test_services.TestDataService object at 0x1665c3dd0&gt;
data_service = &lt;services.data_service.DataService object at 0x166f21280&gt;
mock_session = &lt;MagicMock spec='Session' id='6022106384'&gt;

    def test_add_stock_already_exists(self, data_service, mock_session):
        """Test adding stock that already exists"""
        existing_stock = MagicMock()
        mock_session.query.return_value.filter.return_value.first.return_value = existing_stock
    
        with pytest.raises(TradingAppException) as exc_info:
            data_service.add_stock(mock_session, 'AAPL')
    
&gt;       assert "already being tracked" in str(exc_info.value)
E       assert 'already being tracked' in "Failed to add stock AAPL: '&gt;' not supported between instances of 'MagicMock' and 'int'"
E        +  where "Failed to add stock AAPL: '&gt;' not supported between instances of 'MagicMock' and 'int'" = str(StockDataError("Failed to add stock AAPL: '&gt;' not supported between instances of 'MagicMock' and 'int'"))
E        +    where StockDataError("Failed to add stock AAPL: '&gt;' not supported between instances of 'MagicMock' and 'int'") = &lt;ExceptionInfo StockDataError("Failed to add stock AAPL: '&gt;' not supported between instances of 'MagicMock' and 'int'") tblen=2&gt;.value

tests/test_services.py:255: AssertionError</failure></testcase><testcase classname="tests.test_services.TestDataService" name="test_get_market_data_success" time="0.001"><failure message="AttributeError: module 'services.data_service' has no attribute 'yfinance'">args = (&lt;tests.test_services.TestDataService object at 0x1665f1910&gt;,)
keywargs = {'data_service': &lt;services.data_service.DataService object at 0x167c822a0&gt;}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'services.data_service.yfinance'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'services.data_service' has no attribute 'yfinance'

/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_services.TestRecommendationService" name="test_generate_recommendation_strong_buy" time="0.013"><failure message="AttributeError: &lt;services.recommendation_service.RecommendationService object at 0x167c801a0&gt; does not have the attribute 'get_current_price'">self = &lt;tests.test_services.TestRecommendationService object at 0x1665f0950&gt;
recommendation_service = &lt;services.recommendation_service.RecommendationService object at 0x167c801a0&gt;
mock_session = &lt;MagicMock spec='Session' id='6032474624'&gt;

    def test_generate_recommendation_strong_buy(self, recommendation_service, mock_session):
        """Test recommendation generation for strong buy signal"""
        # Mock sentiment data
        mock_sentiment = MagicMock()
        mock_sentiment.symbol = 'AAPL'
        mock_sentiment.overall_sentiment = 0.8  # Very positive
    
        mock_session.query.return_value.filter.return_value.order_by.return_value.first.return_value = mock_sentiment
    
&gt;       with patch.object(recommendation_service, 'get_current_price', return_value=150.0), \
             patch.object(mock_session, 'add'), \
             patch.object(mock_session, 'commit'):

tests/test_services.py:299: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x16797e4b0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;services.recommendation_service.RecommendationService object at 0x167c801a0&gt; does not have the attribute 'get_current_price'

/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1431: AttributeError</failure></testcase><testcase classname="tests.test_services.TestRecommendationService" name="test_generate_recommendation_strong_sell" time="0.013"><failure message="AttributeError: &lt;services.recommendation_service.RecommendationService object at 0x1623712e0&gt; does not have the attribute 'get_current_price'">self = &lt;tests.test_services.TestRecommendationService object at 0x1665f2870&gt;
recommendation_service = &lt;services.recommendation_service.RecommendationService object at 0x1623712e0&gt;
mock_session = &lt;MagicMock spec='Session' id='6036545584'&gt;

    def test_generate_recommendation_strong_sell(self, recommendation_service, mock_session):
        """Test recommendation generation for strong sell signal"""
        # Mock sentiment data
        mock_sentiment = MagicMock()
        mock_sentiment.symbol = 'AAPL'
        mock_sentiment.overall_sentiment = -0.8  # Very negative
    
        mock_session.query.return_value.filter.return_value.order_by.return_value.first.return_value = mock_sentiment
    
&gt;       with patch.object(recommendation_service, 'get_current_price', return_value=150.0), \
             patch.object(mock_session, 'add'), \
             patch.object(mock_session, 'commit'):

tests/test_services.py:318: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x167c8dca0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;services.recommendation_service.RecommendationService object at 0x1623712e0&gt; does not have the attribute 'get_current_price'

/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1431: AttributeError</failure></testcase><testcase classname="tests.test_services.TestRecommendationService" name="test_generate_recommendation_hold" time="0.015" /><testcase classname="tests.test_services.TestRecommendationService" name="test_approve_recommendation_success" time="0.014"><failure message="exceptions.TradingAppException: Failed to approve recommendation: '&lt;' not supported between instances of 'MagicMock' and 'datetime.datetime'">self = &lt;services.recommendation_service.RecommendationService object at 0x166967c80&gt;
db = &lt;MagicMock spec='Session' id='6015749776'&gt;, recommendation_id = 1

    def approve_recommendation(self, db: Session, recommendation_id: int) -&gt; Dict:
        """Approve and execute a trade recommendation."""
        try:
            recommendation = db.query(TradeRecommendation).filter(
                TradeRecommendation.id == recommendation_id
            ).first()
    
            if not recommendation:
                raise TradingAppException(f"Recommendation {recommendation_id} not found")
    
            if recommendation.status != "PENDING":
                raise TradingAppException(f"Recommendation {recommendation_id} is not pending")
    
&gt;           if recommendation.expires_at and recommendation.expires_at &lt; datetime.now():
E           TypeError: '&lt;' not supported between instances of 'MagicMock' and 'datetime.datetime'

services/recommendation_service.py:270: TypeError

During handling of the above exception, another exception occurred:

self = &lt;tests.test_services.TestRecommendationService object at 0x1665f4d10&gt;
recommendation_service = &lt;services.recommendation_service.RecommendationService object at 0x166967c80&gt;
mock_session = &lt;MagicMock spec='Session' id='6015749776'&gt;

    def test_approve_recommendation_success(self, recommendation_service, mock_session):
        """Test successful recommendation approval"""
        mock_recommendation = MagicMock()
        mock_recommendation.status = 'PENDING'
        mock_recommendation.action = 'BUY'
        mock_recommendation.symbol = 'AAPL'
        mock_recommendation.recommended_quantity = 10
    
        mock_session.query.return_value.filter.return_value.first.return_value = mock_recommendation
    
        with patch('services.recommendation_service.TradingService') as mock_trading:
            mock_trading.return_value.create_trade.return_value = MagicMock(id=1)
    
&gt;           result = recommendation_service.approve_recommendation(mock_session, 1)

tests/test_services.py:355: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;services.recommendation_service.RecommendationService object at 0x166967c80&gt;
db = &lt;MagicMock spec='Session' id='6015749776'&gt;, recommendation_id = 1

    def approve_recommendation(self, db: Session, recommendation_id: int) -&gt; Dict:
        """Approve and execute a trade recommendation."""
        try:
            recommendation = db.query(TradeRecommendation).filter(
                TradeRecommendation.id == recommendation_id
            ).first()
    
            if not recommendation:
                raise TradingAppException(f"Recommendation {recommendation_id} not found")
    
            if recommendation.status != "PENDING":
                raise TradingAppException(f"Recommendation {recommendation_id} is not pending")
    
            if recommendation.expires_at and recommendation.expires_at &lt; datetime.now():
                recommendation.status = "EXPIRED"
                db.commit()
                raise TradingAppException(f"Recommendation {recommendation_id} has expired")
    
            # Create and execute the trade
            trade_data = TradeCreate(
                symbol=recommendation.symbol,
                trade_type=recommendation.action,
                quantity=recommendation.recommended_quantity,
                price=recommendation.current_price,
                strategy="SENTIMENT_RECOMMENDATION"
            )
    
            executed_trade = self.trading_service.create_trade(db, trade_data)
    
            # Update recommendation status
            recommendation.status = "APPROVED"
            recommendation.processed_at = datetime.now()
            recommendation.trade_id = executed_trade.id
    
            db.commit()
    
            self.logger.info(f"Approved and executed recommendation {recommendation_id}: {recommendation.action} {recommendation.symbol}")
    
            return {
                "message": "Recommendation approved and trade executed",
                "recommendation_id": recommendation_id,
                "trade_id": executed_trade.id,
                "trade": executed_trade
            }
    
        except TradingAppException:
            raise
        except Exception as e:
            db.rollback()
            self.logger.error(f"Error approving recommendation {recommendation_id}: {str(e)}")
&gt;           raise TradingAppException(f"Failed to approve recommendation: {str(e)}")
E           exceptions.TradingAppException: Failed to approve recommendation: '&lt;' not supported between instances of 'MagicMock' and 'datetime.datetime'

services/recommendation_service.py:307: TradingAppException</failure></testcase><testcase classname="tests.test_services.TestRecommendationService" name="test_reject_recommendation_success" time="0.014" /><testcase classname="tests.test_trading_api.TestTradingAPI" name="test_get_trades_empty" time="0.006"><failure message="sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: trades&#10;[SQL: SELECT trades.id AS trades_id, trades.symbol AS trades_symbol, trades.trade_type AS trades_trade_type, trades.quantity AS trades_quantity, trades.price AS trades_price, trades.total_value AS trades_total_value, trades.timestamp AS trades_timestamp, trades.status AS trades_status, trades.strategy AS trades_strategy, trades.sentiment_score AS trades_sentiment_score, trades.profit_loss AS trades_profit_loss, trades.close_timestamp AS trades_close_timestamp, trades.close_price AS trades_close_price &#10;FROM trades ORDER BY trades.timestamp DESC]&#10;(Background on this error at: https://sqlalche.me/e/20/e3q8)">self = &lt;sqlalchemy.engine.base.Connection object at 0x166e09c40&gt;
dialect = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
context = &lt;sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x166e09790&gt;
statement = &lt;sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x166e09a30&gt;
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -&gt; CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
&gt;                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
cursor = &lt;sqlite3.Cursor object at 0x167f4b4c0&gt;
statement = 'SELECT trades.id AS trades_id, trades.symbol AS trades_symbol, trades.trade_type AS trades_trade_type, trades.quantit...stamp AS trades_close_timestamp, trades.close_price AS trades_close_price \nFROM trades ORDER BY trades.timestamp DESC'
parameters = ()
context = &lt;sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x166e09790&gt;

    def do_execute(self, cursor, statement, parameters, context=None):
&gt;       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: no such table: trades

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

self = &lt;tests.test_trading_api.TestTradingAPI object at 0x1665f3590&gt;
client = &lt;starlette.testclient.TestClient object at 0x16781ba10&gt;
test_db = &lt;sqlalchemy.orm.session.Session object at 0x16781bb00&gt;

    def test_get_trades_empty(self, client, test_db):
        """Test getting trades when none exist"""
&gt;       response = client.get("/api/trades")

tests/test_trading_api.py:14: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/starlette/testclient.py:499: in get
    return super().get(
venv/lib/python3.12/site-packages/httpx/_client.py:1041: in get
    return self.request(
venv/lib/python3.12/site-packages/starlette/testclient.py:465: in request
    return super().request(
venv/lib/python3.12/site-packages/httpx/_client.py:814: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
venv/lib/python3.12/site-packages/httpx/_client.py:901: in send
    response = self._send_handling_auth(
venv/lib/python3.12/site-packages/httpx/_client.py:929: in _send_handling_auth
    response = self._send_handling_redirects(
venv/lib/python3.12/site-packages/httpx/_client.py:966: in _send_handling_redirects
    response = self._send_single_request(request)
venv/lib/python3.12/site-packages/httpx/_client.py:1002: in _send_single_request
    response = transport.handle_request(request)
venv/lib/python3.12/site-packages/starlette/testclient.py:342: in handle_request
    raise exc
venv/lib/python3.12/site-packages/starlette/testclient.py:339: in handle_request
    portal.call(self.app, scope, receive, send)
venv/lib/python3.12/site-packages/anyio/from_thread.py:277: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/concurrent/futures/_base.py:456: in result
    return self.__get_result()
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/concurrent/futures/_base.py:401: in __get_result
    raise self._exception
venv/lib/python3.12/site-packages/anyio/from_thread.py:217: in _call_func
    retval = await retval
venv/lib/python3.12/site-packages/fastapi/applications.py:1106: in __call__
    await super().__call__(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/applications.py:122: in __call__
    await self.middleware_stack(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/middleware/errors.py:184: in __call__
    raise exc
venv/lib/python3.12/site-packages/starlette/middleware/errors.py:162: in __call__
    await self.app(scope, receive, _send)
venv/lib/python3.12/site-packages/starlette/middleware/base.py:108: in __call__
    response = await self.dispatch_func(request, call_next)
main.py:61: in log_requests
    response = await call_next(request)
venv/lib/python3.12/site-packages/starlette/middleware/base.py:84: in call_next
    raise app_exc
venv/lib/python3.12/site-packages/starlette/middleware/base.py:70: in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
venv/lib/python3.12/site-packages/starlette/middleware/cors.py:83: in __call__
    await self.app(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/middleware/exceptions.py:79: in __call__
    raise exc
venv/lib/python3.12/site-packages/starlette/middleware/exceptions.py:68: in __call__
    await self.app(scope, receive, sender)
venv/lib/python3.12/site-packages/fastapi/middleware/asyncexitstack.py:20: in __call__
    raise e
venv/lib/python3.12/site-packages/fastapi/middleware/asyncexitstack.py:17: in __call__
    await self.app(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/routing.py:718: in __call__
    await route.handle(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/routing.py:276: in handle
    await self.app(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/routing.py:66: in app
    response = await func(request)
venv/lib/python3.12/site-packages/fastapi/routing.py:274: in app
    raw_response = await run_endpoint_function(
venv/lib/python3.12/site-packages/fastapi/routing.py:191: in run_endpoint_function
    return await dependant.call(**values)
main.py:130: in get_trades
    return trading_service.get_all_trades(db)
services/trading_service.py:219: in get_all_trades
    trades = db.query(Trade).order_by(desc(Trade.timestamp)).all()
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2693: in all
    return self._iter().all()  # type: ignore
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2847: in _iter
    result: Union[ScalarResult[_T], Result[_T]] = self.session.execute(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2308: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2190: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:293: in orm_execute_statement
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:516: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1639: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
cursor = &lt;sqlite3.Cursor object at 0x167f4b4c0&gt;
statement = 'SELECT trades.id AS trades_id, trades.symbol AS trades_symbol, trades.trade_type AS trades_trade_type, trades.quantit...stamp AS trades_close_timestamp, trades.close_price AS trades_close_price \nFROM trades ORDER BY trades.timestamp DESC'
parameters = ()
context = &lt;sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x166e09790&gt;

    def do_execute(self, cursor, statement, parameters, context=None):
&gt;       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: trades
E       [SQL: SELECT trades.id AS trades_id, trades.symbol AS trades_symbol, trades.trade_type AS trades_trade_type, trades.quantity AS trades_quantity, trades.price AS trades_price, trades.total_value AS trades_total_value, trades.timestamp AS trades_timestamp, trades.status AS trades_status, trades.strategy AS trades_strategy, trades.sentiment_score AS trades_sentiment_score, trades.profit_loss AS trades_profit_loss, trades.close_timestamp AS trades_close_timestamp, trades.close_price AS trades_close_price 
E       FROM trades ORDER BY trades.timestamp DESC]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError</failure></testcase><testcase classname="tests.test_trading_api.TestTradingAPI" name="test_get_trades_empty" time="0.001"><error message="failed on teardown with &quot;sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 6153777152 and this is thread id 8453168896.&#10;(Background on this error at: https://sqlalche.me/e/20/f405)&quot;">self = &lt;sqlalchemy.engine.base.Connection object at 0x166e09c40&gt;

    def _rollback_impl(self) -&gt; None:
        if self._has_events or self.engine._has_events:
            self.dispatch.rollback(self)
    
        if self._still_open_and_dbapi_connection_is_valid:
            if self._echo:
                if self._is_autocommit_isolation():
                    self._log_info(
                        "ROLLBACK using DBAPI connection.rollback(), "
                        "DBAPI should ignore due to autocommit mode"
                    )
                else:
                    self._log_info("ROLLBACK")
            try:
&gt;               self.engine.dialect.do_rollback(self.connection)

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
dbapi_connection = &lt;sqlalchemy.pool.base._ConnectionFairy object at 0x1669f8050&gt;

    def do_rollback(self, dbapi_connection):
&gt;       dbapi_connection.rollback()
E       sqlite3.ProgrammingError: SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 6153777152 and this is thread id 8453168896.

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:692: ProgrammingError

The above exception was the direct cause of the following exception:

test_engine = Engine(sqlite:///:memory:)

    @pytest.fixture(scope="function")
    def test_db(test_engine):
        """Create a test database session"""
        TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=test_engine)
        session = TestingSessionLocal()
        yield session
&gt;       session.close()

tests/conftest.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2468: in close
    self._close_impl(invalidate=False)
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2537: in _close_impl
    transaction.close(invalidate)
venv/lib/python3.12/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:1362: in close
    transaction.close()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2576: in close
    self._do_close()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2714: in _do_close
    self._close_impl()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2700: in _close_impl
    self._connection_rollback_impl()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2692: in _connection_rollback_impl
    self.connection._rollback_impl()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1121: in _rollback_impl
    self._handle_dbapi_exception(e, None, None, None, None)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1119: in _rollback_impl
    self.engine.dialect.do_rollback(self.connection)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
dbapi_connection = &lt;sqlalchemy.pool.base._ConnectionFairy object at 0x1669f8050&gt;

    def do_rollback(self, dbapi_connection):
&gt;       dbapi_connection.rollback()
E       sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 6153777152 and this is thread id 8453168896.
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:692: ProgrammingError</error></testcase><testcase classname="tests.test_trading_api.TestTradingAPI" name="test_create_trade_success" time="0.003"><failure message="AttributeError: &lt;class 'services.trading_service.TradingService'&gt; does not have the attribute 'get_current_price'">self = &lt;tests.test_trading_api.TestTradingAPI object at 0x1665f3260&gt;
client = &lt;starlette.testclient.TestClient object at 0x166732540&gt;
test_db = &lt;sqlalchemy.orm.session.Session object at 0x166730170&gt;
sample_trade_data = {'price': 150.0, 'quantity': 10, 'strategy': 'MANUAL', 'symbol': 'AAPL', ...}

    def test_create_trade_success(self, client, test_db, sample_trade_data):
        """Test successful trade creation"""
&gt;       with patch('services.trading_service.TradingService.get_current_price') as mock_price:

tests/test_trading_api.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x166732720&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;class 'services.trading_service.TradingService'&gt; does not have the attribute 'get_current_price'

/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1431: AttributeError</failure></testcase><testcase classname="tests.test_trading_api.TestTradingAPI" name="test_create_trade_invalid_symbol" time="0.008"><failure message="assert 400 == 422&#10; +  where 400 = &lt;Response [400 Bad Request]&gt;.status_code">self = &lt;tests.test_trading_api.TestTradingAPI object at 0x1665f3110&gt;
client = &lt;starlette.testclient.TestClient object at 0x166730fe0&gt;
test_db = &lt;sqlalchemy.orm.session.Session object at 0x166730da0&gt;

    def test_create_trade_invalid_symbol(self, client, test_db):
        """Test trade creation with invalid symbol"""
        invalid_trade = {
            "symbol": "",
            "trade_type": "BUY",
            "quantity": 10,
            "price": 150.0
        }
    
        response = client.post("/api/trades", json=invalid_trade)
&gt;       assert response.status_code == 422  # Validation error
E       assert 400 == 422
E        +  where 400 = &lt;Response [400 Bad Request]&gt;.status_code

tests/test_trading_api.py:42: AssertionError</failure></testcase><testcase classname="tests.test_trading_api.TestTradingAPI" name="test_create_trade_insufficient_balance" time="0.003"><failure message="AttributeError: &lt;class 'services.trading_service.TradingService'&gt; does not have the attribute 'get_current_price'">self = &lt;tests.test_trading_api.TestTradingAPI object at 0x1665f2f30&gt;
client = &lt;starlette.testclient.TestClient object at 0x16678f080&gt;
test_db = &lt;sqlalchemy.orm.session.Session object at 0x16678d490&gt;

    def test_create_trade_insufficient_balance(self, client, test_db):
        """Test trade creation with insufficient balance"""
        large_trade = {
            "symbol": "AAPL",
            "trade_type": "BUY",
            "quantity": 1000000,  # Very large quantity
            "price": 150.0
        }
    
&gt;       with patch('services.trading_service.TradingService.get_current_price') as mock_price:

tests/test_trading_api.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x1678815b0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;class 'services.trading_service.TradingService'&gt; does not have the attribute 'get_current_price'

/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1431: AttributeError</failure></testcase><testcase classname="tests.test_trading_api.TestTradingAPI" name="test_get_trade_by_id" time="0.003"><failure message="AttributeError: &lt;class 'services.trading_service.TradingService'&gt; does not have the attribute 'get_current_price'">self = &lt;tests.test_trading_api.TestTradingAPI object at 0x1665f30b0&gt;
client = &lt;starlette.testclient.TestClient object at 0x16678fe60&gt;
test_db = &lt;sqlalchemy.orm.session.Session object at 0x16678d820&gt;
sample_trade_data = {'price': 150.0, 'quantity': 10, 'strategy': 'MANUAL', 'symbol': 'AAPL', ...}

    def test_get_trade_by_id(self, client, test_db, sample_trade_data):
        """Test getting a specific trade by ID"""
        # First create a trade
&gt;       with patch('services.trading_service.TradingService.get_current_price') as mock_price:

tests/test_trading_api.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x166f22570&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;class 'services.trading_service.TradingService'&gt; does not have the attribute 'get_current_price'

/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1431: AttributeError</failure></testcase><testcase classname="tests.test_trading_api.TestTradingAPI" name="test_get_trade_by_id_not_found" time="0.005"><failure message="sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: trades&#10;[SQL: SELECT trades.id AS trades_id, trades.symbol AS trades_symbol, trades.trade_type AS trades_trade_type, trades.quantity AS trades_quantity, trades.price AS trades_price, trades.total_value AS trades_total_value, trades.timestamp AS trades_timestamp, trades.status AS trades_status, trades.strategy AS trades_strategy, trades.sentiment_score AS trades_sentiment_score, trades.profit_loss AS trades_profit_loss, trades.close_timestamp AS trades_close_timestamp, trades.close_price AS trades_close_price &#10;FROM trades &#10;WHERE trades.id = ?&#10; LIMIT ? OFFSET ?]&#10;[parameters: (999, 1, 0)]&#10;(Background on this error at: https://sqlalche.me/e/20/e3q8)">self = &lt;sqlalchemy.engine.base.Connection object at 0x166cc4ef0&gt;
dialect = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
context = &lt;sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x166cc40b0&gt;
statement = &lt;sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x166cc4a40&gt;
parameters = [(999, 1, 0)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -&gt; CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
&gt;                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
cursor = &lt;sqlite3.Cursor object at 0x167bd53c0&gt;
statement = 'SELECT trades.id AS trades_id, trades.symbol AS trades_symbol, trades.trade_type AS trades_trade_type, trades.quantit...rades_close_timestamp, trades.close_price AS trades_close_price \nFROM trades \nWHERE trades.id = ?\n LIMIT ? OFFSET ?'
parameters = (999, 1, 0)
context = &lt;sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x166cc40b0&gt;

    def do_execute(self, cursor, statement, parameters, context=None):
&gt;       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: no such table: trades

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

self = &lt;tests.test_trading_api.TestTradingAPI object at 0x1665f2c60&gt;
client = &lt;starlette.testclient.TestClient object at 0x167881700&gt;
test_db = &lt;sqlalchemy.orm.session.Session object at 0x167882de0&gt;

    def test_get_trade_by_id_not_found(self, client, test_db):
        """Test getting a trade with non-existent ID"""
&gt;       response = client.get("/api/trades/999")

tests/test_trading_api.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/starlette/testclient.py:499: in get
    return super().get(
venv/lib/python3.12/site-packages/httpx/_client.py:1041: in get
    return self.request(
venv/lib/python3.12/site-packages/starlette/testclient.py:465: in request
    return super().request(
venv/lib/python3.12/site-packages/httpx/_client.py:814: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
venv/lib/python3.12/site-packages/httpx/_client.py:901: in send
    response = self._send_handling_auth(
venv/lib/python3.12/site-packages/httpx/_client.py:929: in _send_handling_auth
    response = self._send_handling_redirects(
venv/lib/python3.12/site-packages/httpx/_client.py:966: in _send_handling_redirects
    response = self._send_single_request(request)
venv/lib/python3.12/site-packages/httpx/_client.py:1002: in _send_single_request
    response = transport.handle_request(request)
venv/lib/python3.12/site-packages/starlette/testclient.py:342: in handle_request
    raise exc
venv/lib/python3.12/site-packages/starlette/testclient.py:339: in handle_request
    portal.call(self.app, scope, receive, send)
venv/lib/python3.12/site-packages/anyio/from_thread.py:277: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/concurrent/futures/_base.py:456: in result
    return self.__get_result()
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/concurrent/futures/_base.py:401: in __get_result
    raise self._exception
venv/lib/python3.12/site-packages/anyio/from_thread.py:217: in _call_func
    retval = await retval
venv/lib/python3.12/site-packages/fastapi/applications.py:1106: in __call__
    await super().__call__(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/applications.py:122: in __call__
    await self.middleware_stack(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/middleware/errors.py:184: in __call__
    raise exc
venv/lib/python3.12/site-packages/starlette/middleware/errors.py:162: in __call__
    await self.app(scope, receive, _send)
venv/lib/python3.12/site-packages/starlette/middleware/base.py:108: in __call__
    response = await self.dispatch_func(request, call_next)
main.py:61: in log_requests
    response = await call_next(request)
venv/lib/python3.12/site-packages/starlette/middleware/base.py:84: in call_next
    raise app_exc
venv/lib/python3.12/site-packages/starlette/middleware/base.py:70: in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
venv/lib/python3.12/site-packages/starlette/middleware/cors.py:83: in __call__
    await self.app(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/middleware/exceptions.py:79: in __call__
    raise exc
venv/lib/python3.12/site-packages/starlette/middleware/exceptions.py:68: in __call__
    await self.app(scope, receive, sender)
venv/lib/python3.12/site-packages/fastapi/middleware/asyncexitstack.py:20: in __call__
    raise e
venv/lib/python3.12/site-packages/fastapi/middleware/asyncexitstack.py:17: in __call__
    await self.app(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/routing.py:718: in __call__
    await route.handle(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/routing.py:276: in handle
    await self.app(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/routing.py:66: in app
    response = await func(request)
venv/lib/python3.12/site-packages/fastapi/routing.py:274: in app
    raw_response = await run_endpoint_function(
venv/lib/python3.12/site-packages/fastapi/routing.py:191: in run_endpoint_function
    return await dependant.call(**values)
main.py:150: in get_trade
    return trading_service.get_trade(db, trade_id)
services/trading_service.py:224: in get_trade
    trade = db.query(Trade).filter(Trade.id == trade_id).first()
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2748: in first
    return self.limit(1)._iter().first()  # type: ignore
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2847: in _iter
    result: Union[ScalarResult[_T], Result[_T]] = self.session.execute(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2308: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2190: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:293: in orm_execute_statement
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:516: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1639: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
cursor = &lt;sqlite3.Cursor object at 0x167bd53c0&gt;
statement = 'SELECT trades.id AS trades_id, trades.symbol AS trades_symbol, trades.trade_type AS trades_trade_type, trades.quantit...rades_close_timestamp, trades.close_price AS trades_close_price \nFROM trades \nWHERE trades.id = ?\n LIMIT ? OFFSET ?'
parameters = (999, 1, 0)
context = &lt;sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x166cc40b0&gt;

    def do_execute(self, cursor, statement, parameters, context=None):
&gt;       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: trades
E       [SQL: SELECT trades.id AS trades_id, trades.symbol AS trades_symbol, trades.trade_type AS trades_trade_type, trades.quantity AS trades_quantity, trades.price AS trades_price, trades.total_value AS trades_total_value, trades.timestamp AS trades_timestamp, trades.status AS trades_status, trades.strategy AS trades_strategy, trades.sentiment_score AS trades_sentiment_score, trades.profit_loss AS trades_profit_loss, trades.close_timestamp AS trades_close_timestamp, trades.close_price AS trades_close_price 
E       FROM trades 
E       WHERE trades.id = ?
E        LIMIT ? OFFSET ?]
E       [parameters: (999, 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError</failure></testcase><testcase classname="tests.test_trading_api.TestTradingAPI" name="test_get_trade_by_id_not_found" time="0.001"><error message="failed on teardown with &quot;sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 6153777152 and this is thread id 8453168896.&#10;(Background on this error at: https://sqlalche.me/e/20/f405)&quot;">self = &lt;sqlalchemy.engine.base.Connection object at 0x166cc4ef0&gt;

    def _rollback_impl(self) -&gt; None:
        if self._has_events or self.engine._has_events:
            self.dispatch.rollback(self)
    
        if self._still_open_and_dbapi_connection_is_valid:
            if self._echo:
                if self._is_autocommit_isolation():
                    self._log_info(
                        "ROLLBACK using DBAPI connection.rollback(), "
                        "DBAPI should ignore due to autocommit mode"
                    )
                else:
                    self._log_info("ROLLBACK")
            try:
&gt;               self.engine.dialect.do_rollback(self.connection)

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
dbapi_connection = &lt;sqlalchemy.pool.base._ConnectionFairy object at 0x166c532f0&gt;

    def do_rollback(self, dbapi_connection):
&gt;       dbapi_connection.rollback()
E       sqlite3.ProgrammingError: SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 6153777152 and this is thread id 8453168896.

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:692: ProgrammingError

The above exception was the direct cause of the following exception:

test_engine = Engine(sqlite:///:memory:)

    @pytest.fixture(scope="function")
    def test_db(test_engine):
        """Create a test database session"""
        TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=test_engine)
        session = TestingSessionLocal()
        yield session
&gt;       session.close()

tests/conftest.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2468: in close
    self._close_impl(invalidate=False)
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2537: in _close_impl
    transaction.close(invalidate)
venv/lib/python3.12/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:1362: in close
    transaction.close()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2576: in close
    self._do_close()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2714: in _do_close
    self._close_impl()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2700: in _close_impl
    self._connection_rollback_impl()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2692: in _connection_rollback_impl
    self.connection._rollback_impl()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1121: in _rollback_impl
    self._handle_dbapi_exception(e, None, None, None, None)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1119: in _rollback_impl
    self.engine.dialect.do_rollback(self.connection)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
dbapi_connection = &lt;sqlalchemy.pool.base._ConnectionFairy object at 0x166c532f0&gt;

    def do_rollback(self, dbapi_connection):
&gt;       dbapi_connection.rollback()
E       sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 6153777152 and this is thread id 8453168896.
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:692: ProgrammingError</error></testcase><testcase classname="tests.test_trading_api.TestTradingAPI" name="test_close_trade_success" time="0.003"><failure message="AttributeError: &lt;class 'services.trading_service.TradingService'&gt; does not have the attribute 'get_current_price'">self = &lt;tests.test_trading_api.TestTradingAPI object at 0x1665f2ba0&gt;
client = &lt;starlette.testclient.TestClient object at 0x16678e000&gt;
test_db = &lt;sqlalchemy.orm.session.Session object at 0x16678fb60&gt;
sample_trade_data = {'price': 150.0, 'quantity': 10, 'strategy': 'MANUAL', 'symbol': 'AAPL', ...}

    def test_close_trade_success(self, client, test_db, sample_trade_data):
        """Test successfully closing a trade"""
        # First create a trade
&gt;       with patch('services.trading_service.TradingService.get_current_price') as mock_price:

tests/test_trading_api.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x16678d430&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;class 'services.trading_service.TradingService'&gt; does not have the attribute 'get_current_price'

/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1431: AttributeError</failure></testcase><testcase classname="tests.test_trading_api.TestTradingAPI" name="test_close_trade_with_custom_price" time="0.003"><failure message="AttributeError: &lt;class 'services.trading_service.TradingService'&gt; does not have the attribute 'get_current_price'">self = &lt;tests.test_trading_api.TestTradingAPI object at 0x1665f2090&gt;
client = &lt;starlette.testclient.TestClient object at 0x16678d7f0&gt;
test_db = &lt;sqlalchemy.orm.session.Session object at 0x16678e360&gt;
sample_trade_data = {'price': 150.0, 'quantity': 10, 'strategy': 'MANUAL', 'symbol': 'AAPL', ...}

    def test_close_trade_with_custom_price(self, client, test_db, sample_trade_data):
        """Test closing a trade with custom price"""
        # First create a trade
&gt;       with patch('services.trading_service.TradingService.get_current_price') as mock_price:

tests/test_trading_api.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x166731d60&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;class 'services.trading_service.TradingService'&gt; does not have the attribute 'get_current_price'

/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1431: AttributeError</failure></testcase><testcase classname="tests.test_trading_api.TestTradingAPI" name="test_close_trade_not_found" time="0.005"><failure message="assert 500 == 400&#10; +  where 500 = &lt;Response [500 Internal Server Error]&gt;.status_code">self = &lt;tests.test_trading_api.TestTradingAPI object at 0x1665f27b0&gt;
client = &lt;starlette.testclient.TestClient object at 0x16678ef60&gt;
test_db = &lt;sqlalchemy.orm.session.Session object at 0x16678f9e0&gt;

    def test_close_trade_not_found(self, client, test_db):
        """Test closing a non-existent trade"""
        response = client.post("/api/trades/999/close")
&gt;       assert response.status_code == 400
E       assert 500 == 400
E        +  where 500 = &lt;Response [500 Internal Server Error]&gt;.status_code

tests/test_trading_api.py:123: AssertionError</failure></testcase><testcase classname="tests.test_trading_api.TestTradingAPI" name="test_close_trade_not_found" time="0.001"><error message="failed on teardown with &quot;sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 6153777152 and this is thread id 8453168896.&#10;(Background on this error at: https://sqlalche.me/e/20/f405)&quot;">self = &lt;sqlalchemy.engine.base.Connection object at 0x1678972f0&gt;

    def _rollback_impl(self) -&gt; None:
        if self._has_events or self.engine._has_events:
            self.dispatch.rollback(self)
    
        if self._still_open_and_dbapi_connection_is_valid:
            if self._echo:
                if self._is_autocommit_isolation():
                    self._log_info(
                        "ROLLBACK using DBAPI connection.rollback(), "
                        "DBAPI should ignore due to autocommit mode"
                    )
                else:
                    self._log_info("ROLLBACK")
            try:
&gt;               self.engine.dialect.do_rollback(self.connection)

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
dbapi_connection = &lt;sqlalchemy.pool.base._ConnectionFairy object at 0x16944d5b0&gt;

    def do_rollback(self, dbapi_connection):
&gt;       dbapi_connection.rollback()
E       sqlite3.ProgrammingError: SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 6153777152 and this is thread id 8453168896.

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:692: ProgrammingError

The above exception was the direct cause of the following exception:

test_engine = Engine(sqlite:///:memory:)

    @pytest.fixture(scope="function")
    def test_db(test_engine):
        """Create a test database session"""
        TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=test_engine)
        session = TestingSessionLocal()
        yield session
&gt;       session.close()

tests/conftest.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2468: in close
    self._close_impl(invalidate=False)
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2537: in _close_impl
    transaction.close(invalidate)
venv/lib/python3.12/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:1362: in close
    transaction.close()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2576: in close
    self._do_close()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2714: in _do_close
    self._close_impl()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2700: in _close_impl
    self._connection_rollback_impl()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2692: in _connection_rollback_impl
    self.connection._rollback_impl()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1121: in _rollback_impl
    self._handle_dbapi_exception(e, None, None, None, None)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1119: in _rollback_impl
    self.engine.dialect.do_rollback(self.connection)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
dbapi_connection = &lt;sqlalchemy.pool.base._ConnectionFairy object at 0x16944d5b0&gt;

    def do_rollback(self, dbapi_connection):
&gt;       dbapi_connection.rollback()
E       sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 6153777152 and this is thread id 8453168896.
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:692: ProgrammingError</error></testcase><testcase classname="tests.test_trading_api.TestTradingAPI" name="test_delete_trade_success" time="0.003"><failure message="AttributeError: &lt;class 'services.trading_service.TradingService'&gt; does not have the attribute 'get_current_price'">self = &lt;tests.test_trading_api.TestTradingAPI object at 0x1665f28d0&gt;
client = &lt;starlette.testclient.TestClient object at 0x167896a50&gt;
test_db = &lt;sqlalchemy.orm.session.Session object at 0x1678974a0&gt;
sample_trade_data = {'price': 150.0, 'quantity': 10, 'strategy': 'MANUAL', 'symbol': 'AAPL', ...}

    def test_delete_trade_success(self, client, test_db, sample_trade_data):
        """Test successfully deleting a trade"""
        # First create a trade
&gt;       with patch('services.trading_service.TradingService.get_current_price') as mock_price:

tests/test_trading_api.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x167897590&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;class 'services.trading_service.TradingService'&gt; does not have the attribute 'get_current_price'

/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1431: AttributeError</failure></testcase><testcase classname="tests.test_trading_api.TestTradingAPI" name="test_delete_trade_not_found" time="0.006" /><testcase classname="tests.test_trading_api.TestPerformanceAPI" name="test_get_performance_no_trades" time="0.005"><failure message="KeyError: 'total_trades'">self = &lt;tests.test_trading_api.TestPerformanceAPI object at 0x1665f2480&gt;
client = &lt;starlette.testclient.TestClient object at 0x166cc4b90&gt;
test_db = &lt;sqlalchemy.orm.session.Session object at 0x166cc73e0&gt;

    def test_get_performance_no_trades(self, client, test_db):
        """Test getting performance metrics with no trades"""
        response = client.get("/api/performance")
        assert response.status_code == 200
    
        data = response.json()
&gt;       assert data["total_trades"] == 0
E       KeyError: 'total_trades'

tests/test_trading_api.py:157: KeyError</failure></testcase><testcase classname="tests.test_trading_api.TestPerformanceAPI" name="test_get_performance_no_trades" time="0.001"><error message="failed on teardown with &quot;sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 6153777152 and this is thread id 8453168896.&#10;(Background on this error at: https://sqlalche.me/e/20/f405)&quot;">self = &lt;sqlalchemy.engine.base.Connection object at 0x166cc4830&gt;

    def _rollback_impl(self) -&gt; None:
        if self._has_events or self.engine._has_events:
            self.dispatch.rollback(self)
    
        if self._still_open_and_dbapi_connection_is_valid:
            if self._echo:
                if self._is_autocommit_isolation():
                    self._log_info(
                        "ROLLBACK using DBAPI connection.rollback(), "
                        "DBAPI should ignore due to autocommit mode"
                    )
                else:
                    self._log_info("ROLLBACK")
            try:
&gt;               self.engine.dialect.do_rollback(self.connection)

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
dbapi_connection = &lt;sqlalchemy.pool.base._ConnectionFairy object at 0x166adc3b0&gt;

    def do_rollback(self, dbapi_connection):
&gt;       dbapi_connection.rollback()
E       sqlite3.ProgrammingError: SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 6153777152 and this is thread id 8453168896.

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:692: ProgrammingError

The above exception was the direct cause of the following exception:

test_engine = Engine(sqlite:///:memory:)

    @pytest.fixture(scope="function")
    def test_db(test_engine):
        """Create a test database session"""
        TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=test_engine)
        session = TestingSessionLocal()
        yield session
&gt;       session.close()

tests/conftest.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2468: in close
    self._close_impl(invalidate=False)
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2537: in _close_impl
    transaction.close(invalidate)
venv/lib/python3.12/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:1362: in close
    transaction.close()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2576: in close
    self._do_close()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2714: in _do_close
    self._close_impl()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2700: in _close_impl
    self._connection_rollback_impl()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2692: in _connection_rollback_impl
    self.connection._rollback_impl()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1121: in _rollback_impl
    self._handle_dbapi_exception(e, None, None, None, None)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1119: in _rollback_impl
    self.engine.dialect.do_rollback(self.connection)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
dbapi_connection = &lt;sqlalchemy.pool.base._ConnectionFairy object at 0x166adc3b0&gt;

    def do_rollback(self, dbapi_connection):
&gt;       dbapi_connection.rollback()
E       sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 6153777152 and this is thread id 8453168896.
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:692: ProgrammingError</error></testcase><testcase classname="tests.test_trading_api.TestPerformanceAPI" name="test_get_performance_with_trades" time="0.003"><failure message="AttributeError: &lt;class 'services.trading_service.TradingService'&gt; does not have the attribute 'get_current_price'">self = &lt;tests.test_trading_api.TestPerformanceAPI object at 0x1665f1d60&gt;
client = &lt;starlette.testclient.TestClient object at 0x167894f80&gt;
test_db = &lt;sqlalchemy.orm.session.Session object at 0x1678965a0&gt;
sample_trade_data = {'price': 150.0, 'quantity': 10, 'strategy': 'MANUAL', 'symbol': 'AAPL', ...}

    def test_get_performance_with_trades(self, client, test_db, sample_trade_data):
        """Test getting performance metrics with trades"""
        # Create and close a profitable trade
&gt;       with patch('services.trading_service.TradingService.get_current_price') as mock_price:

tests/test_trading_api.py:166: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x1678955b0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;class 'services.trading_service.TradingService'&gt; does not have the attribute 'get_current_price'

/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1431: AttributeError</failure></testcase><testcase classname="tests.test_trading_api.TestPerformanceAPI" name="test_get_portfolio_history" time="0.006"><error message="failed on teardown with &quot;sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 6153777152 and this is thread id 8453168896.&#10;(Background on this error at: https://sqlalche.me/e/20/f405)&quot;">self = &lt;sqlalchemy.engine.base.Connection object at 0x16797e030&gt;

    def _rollback_impl(self) -&gt; None:
        if self._has_events or self.engine._has_events:
            self.dispatch.rollback(self)
    
        if self._still_open_and_dbapi_connection_is_valid:
            if self._echo:
                if self._is_autocommit_isolation():
                    self._log_info(
                        "ROLLBACK using DBAPI connection.rollback(), "
                        "DBAPI should ignore due to autocommit mode"
                    )
                else:
                    self._log_info("ROLLBACK")
            try:
&gt;               self.engine.dialect.do_rollback(self.connection)

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
dbapi_connection = &lt;sqlalchemy.pool.base._ConnectionFairy object at 0x166ade330&gt;

    def do_rollback(self, dbapi_connection):
&gt;       dbapi_connection.rollback()
E       sqlite3.ProgrammingError: SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 6153777152 and this is thread id 8453168896.

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:692: ProgrammingError

The above exception was the direct cause of the following exception:

test_engine = Engine(sqlite:///:memory:)

    @pytest.fixture(scope="function")
    def test_db(test_engine):
        """Create a test database session"""
        TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=test_engine)
        session = TestingSessionLocal()
        yield session
&gt;       session.close()

tests/conftest.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2468: in close
    self._close_impl(invalidate=False)
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2537: in _close_impl
    transaction.close(invalidate)
venv/lib/python3.12/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:1362: in close
    transaction.close()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2576: in close
    self._do_close()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2714: in _do_close
    self._close_impl()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2700: in _close_impl
    self._connection_rollback_impl()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2692: in _connection_rollback_impl
    self.connection._rollback_impl()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1121: in _rollback_impl
    self._handle_dbapi_exception(e, None, None, None, None)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1119: in _rollback_impl
    self.engine.dialect.do_rollback(self.connection)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
dbapi_connection = &lt;sqlalchemy.pool.base._ConnectionFairy object at 0x166ade330&gt;

    def do_rollback(self, dbapi_connection):
&gt;       dbapi_connection.rollback()
E       sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 6153777152 and this is thread id 8453168896.
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:692: ProgrammingError</error></testcase><testcase classname="tests.test_trading_api.TestPerformanceAPI" name="test_recalculate_balance" time="0.006"><error message="failed on teardown with &quot;sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 6153777152 and this is thread id 8453168896.&#10;(Background on this error at: https://sqlalche.me/e/20/f405)&quot;">self = &lt;sqlalchemy.engine.base.Connection object at 0x166cc63c0&gt;

    def _rollback_impl(self) -&gt; None:
        if self._has_events or self.engine._has_events:
            self.dispatch.rollback(self)
    
        if self._still_open_and_dbapi_connection_is_valid:
            if self._echo:
                if self._is_autocommit_isolation():
                    self._log_info(
                        "ROLLBACK using DBAPI connection.rollback(), "
                        "DBAPI should ignore due to autocommit mode"
                    )
                else:
                    self._log_info("ROLLBACK")
            try:
&gt;               self.engine.dialect.do_rollback(self.connection)

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
dbapi_connection = &lt;sqlalchemy.pool.base._ConnectionFairy object at 0x16944dc10&gt;

    def do_rollback(self, dbapi_connection):
&gt;       dbapi_connection.rollback()
E       sqlite3.ProgrammingError: SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 6153777152 and this is thread id 8453168896.

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:692: ProgrammingError

The above exception was the direct cause of the following exception:

test_engine = Engine(sqlite:///:memory:)

    @pytest.fixture(scope="function")
    def test_db(test_engine):
        """Create a test database session"""
        TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=test_engine)
        session = TestingSessionLocal()
        yield session
&gt;       session.close()

tests/conftest.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2468: in close
    self._close_impl(invalidate=False)
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2537: in _close_impl
    transaction.close(invalidate)
venv/lib/python3.12/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:1362: in close
    transaction.close()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2576: in close
    self._do_close()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2714: in _do_close
    self._close_impl()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2700: in _close_impl
    self._connection_rollback_impl()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2692: in _connection_rollback_impl
    self.connection._rollback_impl()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1121: in _rollback_impl
    self._handle_dbapi_exception(e, None, None, None, None)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1119: in _rollback_impl
    self.engine.dialect.do_rollback(self.connection)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
dbapi_connection = &lt;sqlalchemy.pool.base._ConnectionFairy object at 0x16944dc10&gt;

    def do_rollback(self, dbapi_connection):
&gt;       dbapi_connection.rollback()
E       sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 6153777152 and this is thread id 8453168896.
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:692: ProgrammingError</error></testcase><testcase classname="tests.test_trading_api.TestSentimentAPI" name="test_get_sentiment_empty" time="0.005"><failure message="sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: sentiment_data&#10;[SQL: SELECT sentiment_data.id AS sentiment_data_id, sentiment_data.symbol AS sentiment_data_symbol, sentiment_data.timestamp AS sentiment_data_timestamp, sentiment_data.news_sentiment AS sentiment_data_news_sentiment, sentiment_data.social_sentiment AS sentiment_data_social_sentiment, sentiment_data.overall_sentiment AS sentiment_data_overall_sentiment, sentiment_data.news_count AS sentiment_data_news_count, sentiment_data.social_count AS sentiment_data_social_count, sentiment_data.source AS sentiment_data_source &#10;FROM sentiment_data &#10;WHERE sentiment_data.symbol = ? ORDER BY sentiment_data.timestamp DESC&#10; LIMIT ? OFFSET ?]&#10;[parameters: ('AAPL', 1, 0)]&#10;(Background on this error at: https://sqlalche.me/e/20/e3q8)">self = &lt;sqlalchemy.engine.base.Connection object at 0x167ce7bf0&gt;
dialect = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
context = &lt;sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x167ce5bb0&gt;
statement = &lt;sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x167ce7500&gt;
parameters = [('AAPL', 1, 0)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -&gt; CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
&gt;                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
cursor = &lt;sqlite3.Cursor object at 0x167c36540&gt;
statement = 'SELECT sentiment_data.id AS sentiment_data_id, sentiment_data.symbol AS sentiment_data_symbol, sentiment_data.timesta...urce \nFROM sentiment_data \nWHERE sentiment_data.symbol = ? ORDER BY sentiment_data.timestamp DESC\n LIMIT ? OFFSET ?'
parameters = ('AAPL', 1, 0)
context = &lt;sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x167ce5bb0&gt;

    def do_execute(self, cursor, statement, parameters, context=None):
&gt;       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: no such table: sentiment_data

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

self = &lt;tests.test_trading_api.TestSentimentAPI object at 0x1665f2120&gt;
client = &lt;starlette.testclient.TestClient object at 0x16678de50&gt;
test_db = &lt;sqlalchemy.orm.session.Session object at 0x16678d970&gt;

    def test_get_sentiment_empty(self, client, test_db):
        """Test getting sentiment when none exists"""
&gt;       response = client.get("/api/sentiment")

tests/test_trading_api.py:209: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/starlette/testclient.py:499: in get
    return super().get(
venv/lib/python3.12/site-packages/httpx/_client.py:1041: in get
    return self.request(
venv/lib/python3.12/site-packages/starlette/testclient.py:465: in request
    return super().request(
venv/lib/python3.12/site-packages/httpx/_client.py:814: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
venv/lib/python3.12/site-packages/httpx/_client.py:901: in send
    response = self._send_handling_auth(
venv/lib/python3.12/site-packages/httpx/_client.py:929: in _send_handling_auth
    response = self._send_handling_redirects(
venv/lib/python3.12/site-packages/httpx/_client.py:966: in _send_handling_redirects
    response = self._send_single_request(request)
venv/lib/python3.12/site-packages/httpx/_client.py:1002: in _send_single_request
    response = transport.handle_request(request)
venv/lib/python3.12/site-packages/starlette/testclient.py:342: in handle_request
    raise exc
venv/lib/python3.12/site-packages/starlette/testclient.py:339: in handle_request
    portal.call(self.app, scope, receive, send)
venv/lib/python3.12/site-packages/anyio/from_thread.py:277: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/concurrent/futures/_base.py:456: in result
    return self.__get_result()
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/concurrent/futures/_base.py:401: in __get_result
    raise self._exception
venv/lib/python3.12/site-packages/anyio/from_thread.py:217: in _call_func
    retval = await retval
venv/lib/python3.12/site-packages/fastapi/applications.py:1106: in __call__
    await super().__call__(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/applications.py:122: in __call__
    await self.middleware_stack(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/middleware/errors.py:184: in __call__
    raise exc
venv/lib/python3.12/site-packages/starlette/middleware/errors.py:162: in __call__
    await self.app(scope, receive, _send)
venv/lib/python3.12/site-packages/starlette/middleware/base.py:108: in __call__
    response = await self.dispatch_func(request, call_next)
main.py:61: in log_requests
    response = await call_next(request)
venv/lib/python3.12/site-packages/starlette/middleware/base.py:84: in call_next
    raise app_exc
venv/lib/python3.12/site-packages/starlette/middleware/base.py:70: in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
venv/lib/python3.12/site-packages/starlette/middleware/cors.py:83: in __call__
    await self.app(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/middleware/exceptions.py:79: in __call__
    raise exc
venv/lib/python3.12/site-packages/starlette/middleware/exceptions.py:68: in __call__
    await self.app(scope, receive, sender)
venv/lib/python3.12/site-packages/fastapi/middleware/asyncexitstack.py:20: in __call__
    raise e
venv/lib/python3.12/site-packages/fastapi/middleware/asyncexitstack.py:17: in __call__
    await self.app(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/routing.py:718: in __call__
    await route.handle(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/routing.py:276: in handle
    await self.app(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/routing.py:66: in app
    response = await func(request)
venv/lib/python3.12/site-packages/fastapi/routing.py:274: in app
    raw_response = await run_endpoint_function(
venv/lib/python3.12/site-packages/fastapi/routing.py:191: in run_endpoint_function
    return await dependant.call(**values)
main.py:190: in get_all_sentiment
    return sentiment_service.get_all_sentiment(db)
services/sentiment_service.py:261: in get_all_sentiment
    sentiment = self.get_stock_sentiment(db, symbol)
services/sentiment_service.py:250: in get_stock_sentiment
    ).order_by(desc(SentimentData.timestamp)).first()
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2748: in first
    return self.limit(1)._iter().first()  # type: ignore
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2847: in _iter
    result: Union[ScalarResult[_T], Result[_T]] = self.session.execute(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2308: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2190: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:293: in orm_execute_statement
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:516: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1639: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
cursor = &lt;sqlite3.Cursor object at 0x167c36540&gt;
statement = 'SELECT sentiment_data.id AS sentiment_data_id, sentiment_data.symbol AS sentiment_data_symbol, sentiment_data.timesta...urce \nFROM sentiment_data \nWHERE sentiment_data.symbol = ? ORDER BY sentiment_data.timestamp DESC\n LIMIT ? OFFSET ?'
parameters = ('AAPL', 1, 0)
context = &lt;sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x167ce5bb0&gt;

    def do_execute(self, cursor, statement, parameters, context=None):
&gt;       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: sentiment_data
E       [SQL: SELECT sentiment_data.id AS sentiment_data_id, sentiment_data.symbol AS sentiment_data_symbol, sentiment_data.timestamp AS sentiment_data_timestamp, sentiment_data.news_sentiment AS sentiment_data_news_sentiment, sentiment_data.social_sentiment AS sentiment_data_social_sentiment, sentiment_data.overall_sentiment AS sentiment_data_overall_sentiment, sentiment_data.news_count AS sentiment_data_news_count, sentiment_data.social_count AS sentiment_data_social_count, sentiment_data.source AS sentiment_data_source 
E       FROM sentiment_data 
E       WHERE sentiment_data.symbol = ? ORDER BY sentiment_data.timestamp DESC
E        LIMIT ? OFFSET ?]
E       [parameters: ('AAPL', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError</failure></testcase><testcase classname="tests.test_trading_api.TestSentimentAPI" name="test_get_sentiment_empty" time="0.001"><error message="failed on teardown with &quot;sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 6153777152 and this is thread id 8453168896.&#10;(Background on this error at: https://sqlalche.me/e/20/f405)&quot;">self = &lt;sqlalchemy.engine.base.Connection object at 0x167ce7bf0&gt;

    def _rollback_impl(self) -&gt; None:
        if self._has_events or self.engine._has_events:
            self.dispatch.rollback(self)
    
        if self._still_open_and_dbapi_connection_is_valid:
            if self._echo:
                if self._is_autocommit_isolation():
                    self._log_info(
                        "ROLLBACK using DBAPI connection.rollback(), "
                        "DBAPI should ignore due to autocommit mode"
                    )
                else:
                    self._log_info("ROLLBACK")
            try:
&gt;               self.engine.dialect.do_rollback(self.connection)

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
dbapi_connection = &lt;sqlalchemy.pool.base._ConnectionFairy object at 0x167c8cc50&gt;

    def do_rollback(self, dbapi_connection):
&gt;       dbapi_connection.rollback()
E       sqlite3.ProgrammingError: SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 6153777152 and this is thread id 8453168896.

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:692: ProgrammingError

The above exception was the direct cause of the following exception:

test_engine = Engine(sqlite:///:memory:)

    @pytest.fixture(scope="function")
    def test_db(test_engine):
        """Create a test database session"""
        TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=test_engine)
        session = TestingSessionLocal()
        yield session
&gt;       session.close()

tests/conftest.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2468: in close
    self._close_impl(invalidate=False)
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2537: in _close_impl
    transaction.close(invalidate)
venv/lib/python3.12/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:1362: in close
    transaction.close()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2576: in close
    self._do_close()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2714: in _do_close
    self._close_impl()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2700: in _close_impl
    self._connection_rollback_impl()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2692: in _connection_rollback_impl
    self.connection._rollback_impl()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1121: in _rollback_impl
    self._handle_dbapi_exception(e, None, None, None, None)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1119: in _rollback_impl
    self.engine.dialect.do_rollback(self.connection)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
dbapi_connection = &lt;sqlalchemy.pool.base._ConnectionFairy object at 0x167c8cc50&gt;

    def do_rollback(self, dbapi_connection):
&gt;       dbapi_connection.rollback()
E       sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 6153777152 and this is thread id 8453168896.
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:692: ProgrammingError</error></testcase><testcase classname="tests.test_trading_api.TestSentimentAPI" name="test_get_sentiment_by_symbol_not_found" time="0.004"><failure message="sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: sentiment_data&#10;[SQL: SELECT sentiment_data.id AS sentiment_data_id, sentiment_data.symbol AS sentiment_data_symbol, sentiment_data.timestamp AS sentiment_data_timestamp, sentiment_data.news_sentiment AS sentiment_data_news_sentiment, sentiment_data.social_sentiment AS sentiment_data_social_sentiment, sentiment_data.overall_sentiment AS sentiment_data_overall_sentiment, sentiment_data.news_count AS sentiment_data_news_count, sentiment_data.social_count AS sentiment_data_social_count, sentiment_data.source AS sentiment_data_source &#10;FROM sentiment_data &#10;WHERE sentiment_data.symbol = ? ORDER BY sentiment_data.timestamp DESC&#10; LIMIT ? OFFSET ?]&#10;[parameters: ('NONEXISTENT', 1, 0)]&#10;(Background on this error at: https://sqlalche.me/e/20/e3q8)">self = &lt;sqlalchemy.engine.base.Connection object at 0x16797ecc0&gt;
dialect = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
context = &lt;sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x16797ec90&gt;
statement = &lt;sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x167ce7500&gt;
parameters = [('NONEXISTENT', 1, 0)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -&gt; CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
&gt;                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
cursor = &lt;sqlite3.Cursor object at 0x166e81ec0&gt;
statement = 'SELECT sentiment_data.id AS sentiment_data_id, sentiment_data.symbol AS sentiment_data_symbol, sentiment_data.timesta...urce \nFROM sentiment_data \nWHERE sentiment_data.symbol = ? ORDER BY sentiment_data.timestamp DESC\n LIMIT ? OFFSET ?'
parameters = ('NONEXISTENT', 1, 0)
context = &lt;sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x16797ec90&gt;

    def do_execute(self, cursor, statement, parameters, context=None):
&gt;       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: no such table: sentiment_data

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

self = &lt;tests.test_trading_api.TestSentimentAPI object at 0x1665f26f0&gt;
client = &lt;starlette.testclient.TestClient object at 0x166cc4aa0&gt;
test_db = &lt;sqlalchemy.orm.session.Session object at 0x166cc4890&gt;

    def test_get_sentiment_by_symbol_not_found(self, client, test_db):
        """Test getting sentiment for non-existent symbol"""
&gt;       response = client.get("/api/sentiment/NONEXISTENT")

tests/test_trading_api.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/starlette/testclient.py:499: in get
    return super().get(
venv/lib/python3.12/site-packages/httpx/_client.py:1041: in get
    return self.request(
venv/lib/python3.12/site-packages/starlette/testclient.py:465: in request
    return super().request(
venv/lib/python3.12/site-packages/httpx/_client.py:814: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
venv/lib/python3.12/site-packages/httpx/_client.py:901: in send
    response = self._send_handling_auth(
venv/lib/python3.12/site-packages/httpx/_client.py:929: in _send_handling_auth
    response = self._send_handling_redirects(
venv/lib/python3.12/site-packages/httpx/_client.py:966: in _send_handling_redirects
    response = self._send_single_request(request)
venv/lib/python3.12/site-packages/httpx/_client.py:1002: in _send_single_request
    response = transport.handle_request(request)
venv/lib/python3.12/site-packages/starlette/testclient.py:342: in handle_request
    raise exc
venv/lib/python3.12/site-packages/starlette/testclient.py:339: in handle_request
    portal.call(self.app, scope, receive, send)
venv/lib/python3.12/site-packages/anyio/from_thread.py:277: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/concurrent/futures/_base.py:456: in result
    return self.__get_result()
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/concurrent/futures/_base.py:401: in __get_result
    raise self._exception
venv/lib/python3.12/site-packages/anyio/from_thread.py:217: in _call_func
    retval = await retval
venv/lib/python3.12/site-packages/fastapi/applications.py:1106: in __call__
    await super().__call__(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/applications.py:122: in __call__
    await self.middleware_stack(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/middleware/errors.py:184: in __call__
    raise exc
venv/lib/python3.12/site-packages/starlette/middleware/errors.py:162: in __call__
    await self.app(scope, receive, _send)
venv/lib/python3.12/site-packages/starlette/middleware/base.py:108: in __call__
    response = await self.dispatch_func(request, call_next)
main.py:61: in log_requests
    response = await call_next(request)
venv/lib/python3.12/site-packages/starlette/middleware/base.py:84: in call_next
    raise app_exc
venv/lib/python3.12/site-packages/starlette/middleware/base.py:70: in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
venv/lib/python3.12/site-packages/starlette/middleware/cors.py:83: in __call__
    await self.app(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/middleware/exceptions.py:79: in __call__
    raise exc
venv/lib/python3.12/site-packages/starlette/middleware/exceptions.py:68: in __call__
    await self.app(scope, receive, sender)
venv/lib/python3.12/site-packages/fastapi/middleware/asyncexitstack.py:20: in __call__
    raise e
venv/lib/python3.12/site-packages/fastapi/middleware/asyncexitstack.py:17: in __call__
    await self.app(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/routing.py:718: in __call__
    await route.handle(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/routing.py:276: in handle
    await self.app(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/routing.py:66: in app
    response = await func(request)
venv/lib/python3.12/site-packages/fastapi/routing.py:274: in app
    raw_response = await run_endpoint_function(
venv/lib/python3.12/site-packages/fastapi/routing.py:191: in run_endpoint_function
    return await dependant.call(**values)
main.py:185: in get_sentiment
    return sentiment_service.get_stock_sentiment(db, symbol)
services/sentiment_service.py:250: in get_stock_sentiment
    ).order_by(desc(SentimentData.timestamp)).first()
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2748: in first
    return self.limit(1)._iter().first()  # type: ignore
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2847: in _iter
    result: Union[ScalarResult[_T], Result[_T]] = self.session.execute(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2308: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2190: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:293: in orm_execute_statement
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:516: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1639: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
cursor = &lt;sqlite3.Cursor object at 0x166e81ec0&gt;
statement = 'SELECT sentiment_data.id AS sentiment_data_id, sentiment_data.symbol AS sentiment_data_symbol, sentiment_data.timesta...urce \nFROM sentiment_data \nWHERE sentiment_data.symbol = ? ORDER BY sentiment_data.timestamp DESC\n LIMIT ? OFFSET ?'
parameters = ('NONEXISTENT', 1, 0)
context = &lt;sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x16797ec90&gt;

    def do_execute(self, cursor, statement, parameters, context=None):
&gt;       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: sentiment_data
E       [SQL: SELECT sentiment_data.id AS sentiment_data_id, sentiment_data.symbol AS sentiment_data_symbol, sentiment_data.timestamp AS sentiment_data_timestamp, sentiment_data.news_sentiment AS sentiment_data_news_sentiment, sentiment_data.social_sentiment AS sentiment_data_social_sentiment, sentiment_data.overall_sentiment AS sentiment_data_overall_sentiment, sentiment_data.news_count AS sentiment_data_news_count, sentiment_data.social_count AS sentiment_data_social_count, sentiment_data.source AS sentiment_data_source 
E       FROM sentiment_data 
E       WHERE sentiment_data.symbol = ? ORDER BY sentiment_data.timestamp DESC
E        LIMIT ? OFFSET ?]
E       [parameters: ('NONEXISTENT', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError</failure></testcase><testcase classname="tests.test_trading_api.TestSentimentAPI" name="test_get_sentiment_by_symbol_not_found" time="0.001"><error message="failed on teardown with &quot;sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 6153777152 and this is thread id 8453168896.&#10;(Background on this error at: https://sqlalche.me/e/20/f405)&quot;">self = &lt;sqlalchemy.engine.base.Connection object at 0x16797ecc0&gt;

    def _rollback_impl(self) -&gt; None:
        if self._has_events or self.engine._has_events:
            self.dispatch.rollback(self)
    
        if self._still_open_and_dbapi_connection_is_valid:
            if self._echo:
                if self._is_autocommit_isolation():
                    self._log_info(
                        "ROLLBACK using DBAPI connection.rollback(), "
                        "DBAPI should ignore due to autocommit mode"
                    )
                else:
                    self._log_info("ROLLBACK")
            try:
&gt;               self.engine.dialect.do_rollback(self.connection)

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
dbapi_connection = &lt;sqlalchemy.pool.base._ConnectionFairy object at 0x16944ee70&gt;

    def do_rollback(self, dbapi_connection):
&gt;       dbapi_connection.rollback()
E       sqlite3.ProgrammingError: SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 6153777152 and this is thread id 8453168896.

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:692: ProgrammingError

The above exception was the direct cause of the following exception:

test_engine = Engine(sqlite:///:memory:)

    @pytest.fixture(scope="function")
    def test_db(test_engine):
        """Create a test database session"""
        TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=test_engine)
        session = TestingSessionLocal()
        yield session
&gt;       session.close()

tests/conftest.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2468: in close
    self._close_impl(invalidate=False)
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2537: in _close_impl
    transaction.close(invalidate)
venv/lib/python3.12/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:1362: in close
    transaction.close()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2576: in close
    self._do_close()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2714: in _do_close
    self._close_impl()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2700: in _close_impl
    self._connection_rollback_impl()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2692: in _connection_rollback_impl
    self.connection._rollback_impl()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1121: in _rollback_impl
    self._handle_dbapi_exception(e, None, None, None, None)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1119: in _rollback_impl
    self.engine.dialect.do_rollback(self.connection)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
dbapi_connection = &lt;sqlalchemy.pool.base._ConnectionFairy object at 0x16944ee70&gt;

    def do_rollback(self, dbapi_connection):
&gt;       dbapi_connection.rollback()
E       sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 6153777152 and this is thread id 8453168896.
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:692: ProgrammingError</error></testcase><testcase classname="tests.test_trading_api.TestSentimentAPI" name="test_analyze_sentiment_success" time="0.007" /><testcase classname="tests.test_trading_api.TestSentimentAPI" name="test_analyze_bulk_sentiment" time="0.006"><failure message="assert 500 == 200&#10; +  where 500 = &lt;Response [500 Internal Server Error]&gt;.status_code">self = &lt;tests.test_trading_api.TestSentimentAPI object at 0x1665f3530&gt;
mock_analyze = &lt;MagicMock name='analyze_stock_sentiment' id='6036549760'&gt;
client = &lt;starlette.testclient.TestClient object at 0x167897920&gt;
test_db = &lt;sqlalchemy.orm.session.Session object at 0x167896de0&gt;

    @patch('services.sentiment_service.SentimentService.analyze_stock_sentiment')
    def test_analyze_bulk_sentiment(self, mock_analyze, client, test_db):
        """Test bulk sentiment analysis"""
        mock_analyze.return_value = {
            "symbol": "AAPL",
            "overall_sentiment": 0.5,
            "news_sentiment": 0.6,
            "social_sentiment": 0.4,
            "news_count": 5,
            "social_count": 3,
            "source": "test"
        }
    
        response = client.post(
            "/api/analyze-bulk-sentiment",
            json={"symbols": ["AAPL", "GOOGL"], "force_refresh": True}
        )
&gt;       assert response.status_code == 200
E       assert 500 == 200
E        +  where 500 = &lt;Response [500 Internal Server Error]&gt;.status_code

tests/test_trading_api.py:256: AssertionError</failure></testcase><testcase classname="tests.test_trading_api.TestStocksAPI" name="test_get_stocks_empty" time="0.005"><failure message="sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: stock_data&#10;[SQL: SELECT DISTINCT stock_data.symbol AS stock_data_symbol &#10;FROM stock_data]&#10;(Background on this error at: https://sqlalche.me/e/20/e3q8)">self = &lt;sqlalchemy.engine.base.Connection object at 0x166cc7200&gt;
dialect = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
context = &lt;sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x166cc7380&gt;
statement = &lt;sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x166cc7a40&gt;
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -&gt; CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
&gt;                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
cursor = &lt;sqlite3.Cursor object at 0x1690453c0&gt;
statement = 'SELECT DISTINCT stock_data.symbol AS stock_data_symbol \nFROM stock_data'
parameters = ()
context = &lt;sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x166cc7380&gt;

    def do_execute(self, cursor, statement, parameters, context=None):
&gt;       cursor.execute(statement, parameters)
E       sqlite3.OperationalError: no such table: stock_data

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError

The above exception was the direct cause of the following exception:

self = &lt;tests.test_trading_api.TestStocksAPI object at 0x1665f1580&gt;
client = &lt;starlette.testclient.TestClient object at 0x166f239e0&gt;
test_db = &lt;sqlalchemy.orm.session.Session object at 0x166f22d20&gt;

    def test_get_stocks_empty(self, client, test_db):
        """Test getting stocks when none are tracked"""
&gt;       response = client.get("/api/stocks")

tests/test_trading_api.py:270: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/starlette/testclient.py:499: in get
    return super().get(
venv/lib/python3.12/site-packages/httpx/_client.py:1041: in get
    return self.request(
venv/lib/python3.12/site-packages/starlette/testclient.py:465: in request
    return super().request(
venv/lib/python3.12/site-packages/httpx/_client.py:814: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
venv/lib/python3.12/site-packages/httpx/_client.py:901: in send
    response = self._send_handling_auth(
venv/lib/python3.12/site-packages/httpx/_client.py:929: in _send_handling_auth
    response = self._send_handling_redirects(
venv/lib/python3.12/site-packages/httpx/_client.py:966: in _send_handling_redirects
    response = self._send_single_request(request)
venv/lib/python3.12/site-packages/httpx/_client.py:1002: in _send_single_request
    response = transport.handle_request(request)
venv/lib/python3.12/site-packages/starlette/testclient.py:342: in handle_request
    raise exc
venv/lib/python3.12/site-packages/starlette/testclient.py:339: in handle_request
    portal.call(self.app, scope, receive, send)
venv/lib/python3.12/site-packages/anyio/from_thread.py:277: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/concurrent/futures/_base.py:456: in result
    return self.__get_result()
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/concurrent/futures/_base.py:401: in __get_result
    raise self._exception
venv/lib/python3.12/site-packages/anyio/from_thread.py:217: in _call_func
    retval = await retval
venv/lib/python3.12/site-packages/fastapi/applications.py:1106: in __call__
    await super().__call__(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/applications.py:122: in __call__
    await self.middleware_stack(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/middleware/errors.py:184: in __call__
    raise exc
venv/lib/python3.12/site-packages/starlette/middleware/errors.py:162: in __call__
    await self.app(scope, receive, _send)
venv/lib/python3.12/site-packages/starlette/middleware/base.py:108: in __call__
    response = await self.dispatch_func(request, call_next)
main.py:61: in log_requests
    response = await call_next(request)
venv/lib/python3.12/site-packages/starlette/middleware/base.py:84: in call_next
    raise app_exc
venv/lib/python3.12/site-packages/starlette/middleware/base.py:70: in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
venv/lib/python3.12/site-packages/starlette/middleware/cors.py:83: in __call__
    await self.app(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/middleware/exceptions.py:79: in __call__
    raise exc
venv/lib/python3.12/site-packages/starlette/middleware/exceptions.py:68: in __call__
    await self.app(scope, receive, sender)
venv/lib/python3.12/site-packages/fastapi/middleware/asyncexitstack.py:20: in __call__
    raise e
venv/lib/python3.12/site-packages/fastapi/middleware/asyncexitstack.py:17: in __call__
    await self.app(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/routing.py:718: in __call__
    await route.handle(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/routing.py:276: in handle
    await self.app(scope, receive, send)
venv/lib/python3.12/site-packages/starlette/routing.py:66: in app
    response = await func(request)
venv/lib/python3.12/site-packages/fastapi/routing.py:274: in app
    raw_response = await run_endpoint_function(
venv/lib/python3.12/site-packages/fastapi/routing.py:191: in run_endpoint_function
    return await dependant.call(**values)
main.py:238: in get_stocks
    return data_service.get_tracked_stocks(db)
services/data_service.py:159: in get_tracked_stocks
    symbols = [row[0] for row in db.query(StockData.symbol).distinct().all()]
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2693: in all
    return self._iter().all()  # type: ignore
venv/lib/python3.12/site-packages/sqlalchemy/orm/query.py:2847: in _iter
    result: Union[ScalarResult[_T], Result[_T]] = self.session.execute(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2308: in execute
    return self._execute_internal(
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2190: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
venv/lib/python3.12/site-packages/sqlalchemy/orm/context.py:293: in orm_execute_statement
    result = conn.execute(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
venv/lib/python3.12/site-packages/sqlalchemy/sql/elements.py:516: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1639: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
cursor = &lt;sqlite3.Cursor object at 0x1690453c0&gt;
statement = 'SELECT DISTINCT stock_data.symbol AS stock_data_symbol \nFROM stock_data'
parameters = ()
context = &lt;sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x166cc7380&gt;

    def do_execute(self, cursor, statement, parameters, context=None):
&gt;       cursor.execute(statement, parameters)
E       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: stock_data
E       [SQL: SELECT DISTINCT stock_data.symbol AS stock_data_symbol 
E       FROM stock_data]
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:922: OperationalError</failure></testcase><testcase classname="tests.test_trading_api.TestStocksAPI" name="test_get_stocks_empty" time="0.002"><error message="failed on teardown with &quot;sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 6153777152 and this is thread id 8453168896.&#10;(Background on this error at: https://sqlalche.me/e/20/f405)&quot;">self = &lt;sqlalchemy.engine.base.Connection object at 0x166cc7200&gt;

    def _rollback_impl(self) -&gt; None:
        if self._has_events or self.engine._has_events:
            self.dispatch.rollback(self)
    
        if self._still_open_and_dbapi_connection_is_valid:
            if self._echo:
                if self._is_autocommit_isolation():
                    self._log_info(
                        "ROLLBACK using DBAPI connection.rollback(), "
                        "DBAPI should ignore due to autocommit mode"
                    )
                else:
                    self._log_info("ROLLBACK")
            try:
&gt;               self.engine.dialect.do_rollback(self.connection)

venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
dbapi_connection = &lt;sqlalchemy.pool.base._ConnectionFairy object at 0x167c6b470&gt;

    def do_rollback(self, dbapi_connection):
&gt;       dbapi_connection.rollback()
E       sqlite3.ProgrammingError: SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 6153777152 and this is thread id 8453168896.

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:692: ProgrammingError

The above exception was the direct cause of the following exception:

test_engine = Engine(sqlite:///:memory:)

    @pytest.fixture(scope="function")
    def test_db(test_engine):
        """Create a test database session"""
        TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=test_engine)
        session = TestingSessionLocal()
        yield session
&gt;       session.close()

tests/conftest.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2468: in close
    self._close_impl(invalidate=False)
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:2537: in _close_impl
    transaction.close(invalidate)
venv/lib/python3.12/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
venv/lib/python3.12/site-packages/sqlalchemy/orm/session.py:1362: in close
    transaction.close()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2576: in close
    self._do_close()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2714: in _do_close
    self._close_impl()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2700: in _close_impl
    self._connection_rollback_impl()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2692: in _connection_rollback_impl
    self.connection._rollback_impl()
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1121: in _rollback_impl
    self._handle_dbapi_exception(e, None, None, None, None)
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.12/site-packages/sqlalchemy/engine/base.py:1119: in _rollback_impl
    self.engine.dialect.do_rollback(self.connection)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x166a6c800&gt;
dbapi_connection = &lt;sqlalchemy.pool.base._ConnectionFairy object at 0x167c6b470&gt;

    def do_rollback(self, dbapi_connection):
&gt;       dbapi_connection.rollback()
E       sqlalchemy.exc.ProgrammingError: (sqlite3.ProgrammingError) SQLite objects created in a thread can only be used in that same thread. The object was created in thread id 6153777152 and this is thread id 8453168896.
E       (Background on this error at: https://sqlalche.me/e/20/f405)

venv/lib/python3.12/site-packages/sqlalchemy/engine/default.py:692: ProgrammingError</error></testcase><testcase classname="tests.test_trading_api.TestStocksAPI" name="test_add_stock_success" time="0.007"><failure message="assert 400 == 200&#10; +  where 400 = &lt;Response [400 Bad Request]&gt;.status_code">self = &lt;tests.test_trading_api.TestStocksAPI object at 0x1665f0f80&gt;
client = &lt;starlette.testclient.TestClient object at 0x166f203e0&gt;
test_db = &lt;sqlalchemy.orm.session.Session object at 0x166f22900&gt;

    def test_add_stock_success(self, client, test_db):
        """Test successfully adding a stock"""
        response = client.post("/api/stocks", json={"symbol": "AAPL"})
&gt;       assert response.status_code == 200
E       assert 400 == 200
E        +  where 400 = &lt;Response [400 Bad Request]&gt;.status_code

tests/test_trading_api.py:277: AssertionError</failure></testcase><testcase classname="tests.test_trading_api.TestStocksAPI" name="test_add_stock_invalid_format" time="0.005" /><testcase classname="tests.test_trading_api.TestStocksAPI" name="test_add_stock_too_long" time="0.005" /><testcase classname="tests.test_trading_api.TestStocksAPI" name="test_get_market_data" time="0.005" /><testcase classname="tests.test_trading_api.TestStrategyAPI" name="test_run_strategy_success" time="0.006" /></testsuite></testsuites>